<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Analytics</name>
    </assembly>
    <members>
        <member name="T:Analytics.Types">
            <summary>
            Types
            </summary>
        </member>
        <member name="F:Analytics.Types.BooleanType">
            <summary>
            Boolean type
            </summary>
        </member>
        <member name="F:Analytics.Types.BooleanArrayType">
            <summary>
            Real Array type
            </summary>
        </member>
        <member name="F:Analytics.Types.BooleanMatrixType">
            <summary>
            Real Matrix type
            </summary>
        </member>
        <member name="F:Analytics.Types.BooleanBlockType">
            <summary>
            Real Block type
            </summary>
        </member>
        <member name="F:Analytics.Types.RealType">
            <summary>
            Real type
            </summary>
        </member>
        <member name="F:Analytics.Types.RealArrayType">
            <summary>
            Real Array type
            </summary>
        </member>
        <member name="F:Analytics.Types.RealMatrixType">
            <summary>
            Real Matrix type
            </summary>
        </member>
        <member name="F:Analytics.Types.RealBlockType">
            <summary>
            Real Block type
            </summary>
        </member>
        <member name="F:Analytics.Types.ComplexType">
            <summary>
            Complex type
            </summary>
        </member>
        <member name="F:Analytics.Types.ComplexArrayType">
            <summary>
            Complex Array type
            </summary>
        </member>
        <member name="F:Analytics.Types.ComplexMatrixType">
            <summary>
            Complex Matrix type
            </summary>
        </member>
        <member name="F:Analytics.Types.ComplexBlockType">
            <summary>
            Complex Block type
            </summary>
        </member>
        <member name="M:Analytics.Types.#cctor">
            <summary>
            Static constructor (initializes all data)
            </summary>
        </member>
        <member name="T:Analytics.Constants">
            <summary>
            Constants
            </summary>
        </member>
        <member name="F:Analytics.Constants.IntegerValuePrecision">
            <summary>
            Precision for REAL values to be considered as Integer
            </summary>
        </member>
        <member name="F:Analytics.Constants.RealConstantPrecision">
            <summary>
            Precision for real values to be concidered as 'standard' constants - Pi, e and so on.
            </summary>
        </member>
        <member name="F:Analytics.Constants.RealEqualityPrecision">
            <summary>
            Precision for comparison real values to be concidered as equal.
            </summary>
        </member>
        <member name="F:Analytics.Constants.MaxFractionValue">
            <summary>
            Max value of numerator and denominator to represent common fraction in expressions
            (else the value will be reduced to double value).
            </summary>
        </member>
        <member name="M:Analytics.Constants.#cctor">
            <summary>
            Static constructor (initializes all data)
            </summary>
        </member>
        <member name="T:Analytics.LevelData">
            <summary>
            Parsing levels data
            </summary>
        </member>
        <member name="M:Analytics.LevelData.#ctor(System.Int32)">
            <summary>
            Creates intial levels with 0 values
            </summary>
        </member>
        <member name="T:Analytics.CheckedData`1">
            <summary>
            Data for Checked result
            </summary>
        </member>
        <member name="T:Analytics.ValueData">
            <summary>
            Data for some Value
            </summary>
        </member>
        <member name="T:Analytics.CompareData`1">
            <summary>
            Data for comparison
            </summary>
        </member>
        <member name="T:Analytics.CompareTypes">
            <summary>
            Data for comparison
            </summary>
        </member>
        <member name="T:Analytics.OperatorList`2">
            <summary>
            Pair of lists - operators and operands
            </summary>
        </member>
        <member name="T:Analytics.StringOperators">
            <summary>
            String operators and operands
            </summary>
        </member>
        <member name="T:Analytics.OperatorData">
            <summary>
            Unary operator data
            </summary>
        </member>
        <member name="T:Analytics.FunctionData">
            <summary>
            Function data
            </summary>
        </member>
        <member name="T:Analytics.ItemData">
            <summary>
            Array Item data
            </summary>
        </member>
        <member name="T:Analytics.VectorData">
            <summary>
            Vector data
            </summary>
        </member>
        <member name="T:Analytics.MatrixData">
            <summary>
            Matrix data
            </summary>
        </member>
        <member name="T:Analytics.DerivativeData">
            <summary>
            Derivative data
            </summary>
        </member>
        <member name="T:Analytics.IntegralData">
            <summary>
            Integral data
            </summary>
        </member>
        <member name="T:Analytics.ValueToString">
            <summary>
            Value to String Conversion method.
            </summary>
        </member>
        <member name="T:Analytics.LiteralIs">
            <summary>
            Is literal method
            </summary>
        </member>
        <member name="T:Analytics.LiteralEvaluate">
            <summary>
            Literal Evaluation method
            </summary>
        </member>
        <member name="T:Analytics.FunctionMethod">
            <summary>
            Function calculation method
            </summary>
        </member>
        <member name="T:Analytics.OperationMethod">
            <summary>
            Operation calculation method
            </summary>
        </member>
        <member name="T:Analytics.GenericUnaryOperation`2">
            <summary>
            Generic Unary operation delegate
            </summary>
        </member>
        <member name="T:Analytics.GenericBinaryOperation`3">
            <summary>
            Generic Binary operation delegate
            </summary>
        </member>
        <member name="T:Analytics.Formulae.ImplicitOperatorFormula">
            <summary>
            Base class for Implict operator Formula - calculates its explicit formula.
            </summary>
        </member>
        <member name="M:Analytics.Formulae.ImplicitOperatorFormula.Calculate">
            <summary>
            Calculates explicit formula.
            </summary>
        </member>
        <member name="T:Analytics.Formulae.ArrayFormula">
            <summary>
            Base class for Array Formula - rectangular multidimensional (vector, matrix, block).
            </summary>
        </member>
        <member name="F:Analytics.Formulae.ArrayFormula.itemType">
            <summary>
            Item type info
            NOTE: array type info stored in result type
            </summary>
        </member>
        <member name="F:Analytics.Formulae.ArrayFormula.items">
            <summary>
            Items formulae
            </summary>
        </member>
        <member name="F:Analytics.Formulae.ArrayFormula.itemValues">
            <summary>
            Item values
            </summary>
        </member>
        <member name="M:Analytics.Formulae.ArrayFormula.#ctor(System.Type,Analytics.Formulae.Formula[],System.Int32[])">
            <summary>
            Constructor.
            NOTE: array type information required,
                  it cannot be got from item's formula, because of possibly using ancestor types.
            </summary>
        </member>
        <member name="M:Analytics.Formulae.ArrayFormula.Calculate">
            <summary>
            Calculates
            </summary>
        </member>
        <member name="T:Analytics.Formulae.VectorFormula">
            <summary>
            Vector Formula.
            </summary>
        </member>
        <member name="M:Analytics.Formulae.VectorFormula.#ctor(System.Type,Analytics.Formulae.Formula[])">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="T:Analytics.Formulae.MatrixFormula">
            <summary>
            Matrix Formula.
            </summary>
        </member>
        <member name="M:Analytics.Formulae.MatrixFormula.#ctor(System.Type,Analytics.Formulae.Formula[],System.Int32,System.Int32)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="T:Analytics.Formulae.LiteralFormula">
            <summary>
            Literal value
            </summary>
        </member>
        <member name="F:Analytics.Formulae.LiteralFormula.literal">
            <summary>
            Literal value
            </summary>
        </member>
        <member name="M:Analytics.Formulae.LiteralFormula.#ctor(System.Type,System.Object)">
            <summary>
            Constructor
            </summary>
            <param name="t">Type of literal (because value can be null)</param>
            <param name="value">Literal value</param>
        </member>
        <member name="M:Analytics.Formulae.LiteralFormula.Calculate">
            <summary>
            Returns literal value.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Analytics.Formulae.VariableFormula">
            <summary>
            Variable formula - contains reference to a variable (of any type - Scalar, Array...)
            Variable cannot be null, but variable value can.
            </summary>
        </member>
        <member name="F:Analytics.Formulae.VariableFormula.variable">
            <summary>
            Variable
            </summary>
        </member>
        <member name="M:Analytics.Formulae.VariableFormula.Calculate">
            <summary>
            Returns the Variable Value
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Formulae.VariableFormula.#ctor(Analytics.Variables.Variable)">
            <summary>
            Constructor
            </summary>
            <param name="v">Variable (cannot be null)</param>
        </member>
        <member name="T:Analytics.Formulae.IndexingFormula">
            <summary>
            Indexed data Item formula. 
            Contains reference to an Indexed Variable
            and indexes formulae. Result is the data item with the current index values.
            NOTE: Index formulae MUST return values that can be converted to integer values.
                  Now it is Double only. AND the calculated values MUST be with fraction==.000
                  (that is the value must be almost integer - see Constants.RealIndexPrecision).
            NOTE: Slicing implemented for indexed data that supports it.
            </summary>
        </member>
        <member name="F:Analytics.Formulae.IndexingFormula.source">
            <summary>
            Source array
            </summary>
        </member>
        <member name="F:Analytics.Formulae.IndexingFormula.indexcount">
            <summary>
            Index count
            </summary>
        </member>
        <member name="F:Analytics.Formulae.IndexingFormula.indexes">
            <summary>
            Index formulae
            </summary>
        </member>
        <member name="F:Analytics.Formulae.IndexingFormula.indexValues">
            <summary>
            Index values
            </summary>
        </member>
        <member name="M:Analytics.Formulae.IndexingFormula.#ctor(Analytics.Variables.IndexedVariable,System.Collections.Generic.List{Analytics.Formulae.Formula})">
            <summary>
            Constructor
            </summary>
            <param name="a">Source indexed variable (CANNOT be null)</param>
            <param name="aindexes">Index Formulae (CANNOT be null)</param>
        </member>
        <member name="M:Analytics.Formulae.IndexingFormula.Calculate">
            <summary>
            Returns array item for the current index values
            </summary>
            <returns></returns>
        </member>
        <member name="T:Analytics.Formulae.FunctionFormula">
            <summary>
            Function formula.
            Contains reference to a function calculation method
            parameter and argument formulae.
            </summary>
        </member>
        <member name="F:Analytics.Formulae.FunctionFormula.function">
            <summary>
            Source function
            </summary>
        </member>
        <member name="F:Analytics.Formulae.FunctionFormula.parametercount">
            <summary>
            Parameter count
            </summary>
        </member>
        <member name="F:Analytics.Formulae.FunctionFormula.argumentcount">
            <summary>
            Argument count
            </summary>
        </member>
        <member name="F:Analytics.Formulae.FunctionFormula.parameters">
            <summary>
            Parameter Formulae
            </summary>
        </member>
        <member name="F:Analytics.Formulae.FunctionFormula.arguments">
            <summary>
            Argument Formulae
            </summary>
        </member>
        <member name="F:Analytics.Formulae.FunctionFormula.parameterValues">
            <summary>
            Parameter values
            </summary>
        </member>
        <member name="F:Analytics.Formulae.FunctionFormula.argumentValues">
            <summary>
            Argument values
            </summary>
        </member>
        <member name="M:Analytics.Formulae.FunctionFormula.#ctor(Analytics.Functions.Function,System.Collections.Generic.List{Analytics.Formulae.Formula},System.Collections.Generic.List{Analytics.Formulae.Formula})">
            <summary>
            Constructor.
            The count and types of parameter and argument formulae must
            be the same as of Function (types must be compatible).
            </summary>
            <param name="f">Function (CANNOT be null)</param>
            <param name="prms"></param>
            <param name="args"></param>
        </member>
        <member name="M:Analytics.Formulae.FunctionFormula.Calculate">
            <summary>
            Calculates Function value for the current parameter and argument values.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Analytics.Formulae.UnaryOperationFormula">
            <summary>
            Unary Operation Formula.
            Cantains reference to an Unary Operation method and an Operand Formula.
            </summary>
        </member>
        <member name="F:Analytics.Formulae.UnaryOperationFormula.operation">
            <summary>
            Operation
            </summary>
        </member>
        <member name="F:Analytics.Formulae.UnaryOperationFormula.operand">
            <summary>
            Operand
            </summary>
        </member>
        <member name="F:Analytics.Formulae.UnaryOperationFormula.operandValue">
            <summary>
            (1) Operand value
            </summary>
        </member>
        <member name="M:Analytics.Formulae.UnaryOperationFormula.#ctor(Analytics.Operators.UnaryOperator,Analytics.Formulae.Formula)">
            <summary>
            Constructor.
            </summary>
            <param name="op">Operator (CANNOT be null)</param>
            <param name="opnd">Operand (CANNOT be null)</param>
        </member>
        <member name="M:Analytics.Formulae.UnaryOperationFormula.Calculate">
            <summary>
            Calculates unary operation result for the current operand value
            </summary>
            <returns></returns>
        </member>
        <member name="T:Analytics.Formulae.BinaryOperationsFormula">
            <summary>
            Binary Operation Formula.
            Contains reference to a sequence of Binary Operation methods and their Operand Formulae.
            </summary>
        </member>
        <member name="F:Analytics.Formulae.BinaryOperationsFormula.operations">
            <summary>
            Operations
            </summary>
        </member>
        <member name="F:Analytics.Formulae.BinaryOperationsFormula.operands">
            <summary>
            Operands
            </summary>
        </member>
        <member name="F:Analytics.Formulae.BinaryOperationsFormula.operandValues">
            <summary>
            Operand values (in the order of calculation)
            </summary>
        </member>
        <member name="F:Analytics.Formulae.BinaryOperationsFormula.operatorOperands">
            <summary>
            Operand values for an operator (two operands)
            </summary>
        </member>
        <member name="F:Analytics.Formulae.BinaryOperationsFormula.operationcount">
            <summary>
            Count of operations
            </summary>
        </member>
        <member name="M:Analytics.Formulae.BinaryOperationsFormula.#ctor(Analytics.Operators.BinaryOperator[],Analytics.Formulae.Formula[])">
            <summary>
            Constructor.
            NOTE: The number of operands must be the number of operators +1.
                  The number of operators CAN be 0, because it must be compatible
                  whith Expression realization (binary operations expression
                  can be degenerated during simplification, so it can contain one operand only).
            </summary>
            <param name="ops">Binary Operators (CANNOT be null)</param>
            <param name="opnds">Operands (CANNOT be null)</param>
        </member>
        <member name="P:Analytics.Formulae.BinaryOperationsFormula.OperationCount">
            <summary>
            Count of operations
            </summary>
        </member>
        <member name="M:Analytics.Formulae.BinaryOperationsFormula.Calculate">
            <summary>
            Calculates the sequence of binary operations for the current operand values
            (returns the last operation result).
            TODO: now the operator associativity is not taken into account
                  (LEFT associativity is applied)
            </summary>
            <returns></returns>
        </member>
        <member name="T:Analytics.Formulae.Formula">
            <summary>
            Abstract base class for any formula.
            
            Formula is an object that can be 'calculated' for current state.
            It contains references to constant and variable values, 
            function and operator calculation methods,
            and defines the algorithm to calculate result for the current state.
            Formula classes are organized in the same hierarchy as expressions are -
            each formula class corresponds to an expression class.
            </summary>
        </member>
        <member name="F:Analytics.Formulae.Formula.resultType">
            <summary>
            Result Type
            </summary>
        </member>
        <member name="M:Analytics.Formulae.Formula.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="P:Analytics.Formulae.Formula.ResultType">
            <summary>
            Result Type
            </summary>
        </member>
        <member name="M:Analytics.Formulae.Formula.Calculate">
            <summary>
            Calculates Result value for the current state
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Formulae.Formula.ToString">
            <summary>
            ToString
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Formulae.Formula.GetResultTypes(System.Collections.Generic.List{Analytics.Formulae.Formula})">
            <summary>
            Gets formula result types
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Formulae.Formula.CalculateArray(System.Int32,Analytics.Formulae.Formula[],System.Object[])">
            <summary>
            Calculates all (not null) formulae in arrray and saves values to the result array
            (if some formula is null - assigns null value to the result item).
            </summary>
        </member>
        <member name="T:Analytics.Formulae.SimpleFormula">
            <summary>
            Simple formula does not contain any other formula.
            </summary>
        </member>
        <member name="T:Analytics.Formulae.StructuredFormula">
            <summary>
            Structured formula contains other formulae.
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.ImplicitOperatorExpression">
            <summary>
            Implicit operator expression (makes implict symbolic operation
            with its operand, like derivation or integration).
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.ImplicitOperatorExpression.Operand">
            <summary>
            Operand expression.
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.ImplicitOperatorExpression.Explicit">
            <summary>
            Explicit expression after implicit operation with operand
            NOTE: lazy realization.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.ImplicitOperatorExpression.BuildSame(Analytics.Syntactic.BaseExpression)">
            <summary>
            Builds the same expression with another operand.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.ImplicitOperatorExpression.IsConstant">
            <summary>
            Implicit Expression is constant if the operand is.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.ImplicitOperatorExpression.DependsOn(System.String)">
            <summary>
            Default for Implicit: depends on a variable if the operand does.
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.ImplicitOperatorExpression.Degenerated">
            <summary>
            Returns the operand expression.
            WARNING: DOES NOT check if the expression is degenerated.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.ImplicitOperatorExpression.GetExplicitLazy">
            <summary>
            Lazy realization of Explicit getter.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.ImplicitOperatorExpression.ReplaceInOperand(System.String,Analytics.Syntactic.BaseExpression)">
            <summary>
            Replaces variable by given expression inside the Operand.
            NOTE: DOES NOT update Explicit.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.ImplicitOperatorExpression.ReplaceInside(System.String,Analytics.Syntactic.BaseExpression)">
            <summary>
            Replaces variable by given expression in the Operand
            and Updates explicit if required.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.ImplicitOperatorExpression.GetExplicit(System.Boolean)">
            <summary>
            Gets copy of the explicit expression.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.ImplicitOperatorExpression.Simplify">
            <summary>
            Default simplification algorithm -
            simplify operand, merges degenerated and then merge operation,
            simplify with base rules and finally updates explicit expression and simplifies it.
            WARNING: expression can be degenerated after simplification.
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.ArrayExpression">
            <summary>
            Base abstract class for all Array expressions -
            rectangular multidimensional (vector, matrix, block).
            </summary>
        </member>
        <member name="F:Analytics.Syntactic.ArrayExpression.data">
            <summary>
            Data expressions (multidimensional data presented as array)
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.ArrayExpression.GetSelfPrecedence">
            <summary>
            Gets the Precedence of the expression type.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.ArrayExpression.GetExplicit(System.Boolean)">
            <summary>
            Gets copy of the expression, expanding containing implicit items.
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.ArrayExpression.Dimension">
            <summary>
            Dimension number
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.ArrayExpression.Length">
            <summary>
            Length (total number of elements)
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.ArrayExpression.Size(System.Int32)">
            <summary>
            Size of the dimension
            NOTE: dimension index begins with 1.
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.ArrayExpression.Data">
            <summary>
            Data expressions (multidimensional data presented as array)
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.LiteralExpression">
            <summary>
            Literal 
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.GetPrecedence">
            <summary>
            Gets the Precedence of the expression.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="aValue">This is the value of the literal</param>
        </member>
        <member name="P:Analytics.Syntactic.LiteralExpression.Value">
            <summary>
            Value of the literal
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.Simplify">
            <summary>
            Simplifies constant expression - extracts known constants.
            Now only constants detected by parser are simplified (real and complex).
            We cannot detect Pi/2 value, because we cannot change the type
            of Expression from Literal to Binary operations.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.Reconstruct">
            <summary>
            Reconstructed expression
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.IsConstant">
            <summary>
            Literal is always constant.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.DependsOn(System.String)">
            <summary>
            The expression depends on a variable.
            </summary>
            <param name="vName">Variable Name</param>
            <returns>False (literal is constant)</returns>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.Derivative(Analytics.Derivatives.DerivativeContext,System.String)">
            <summary>
            Calculates Expression Derivative
            </summary>
            <param name="context">Derivative Context</param>
            <param name="vName">Variable Name</param>
            <returns>Derivative expression</returns>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.ToString">
            <summary>
            To string
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.Print(System.Int32)">
            <summary>
            Print string (just for testing)
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.LiteralExpression.Zero">
            <summary>
            Zero Literal.
            Use to return as calculation result,
            DO NOT use to compare literals (use IsZero).
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.LiteralExpression.Unit">
            <summary>
            Unit Literal.
            Use to return as calculation result,
            DO NOT use to compare literals (use IsUnit).
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.LiteralExpression.Euler">
            <summary>
            Euler number e Literal.
            Use to return as calculation result,
            DO NOT use to compare literals (use IsEuler).
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.LiteralExpression.Pi">
            <summary>
            Pi number Literal.
            Use to return as calculation result,
            DO NOT use to compare literals (use IsPi).
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.LiteralExpression.NaN">
            <summary>
            NaN Literal.
            Use to return as calculation result,
            DO NOT use to compare literals (use IsNaN).
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.LiteralExpression.Infinity">
            <summary>
            Infinity Literal.
            Use to return as calculation result,
            DO NOT use to compare literals (use IsInfinity).
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.LiteralExpression.False">
            <summary>
            False literal.
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.LiteralExpression.True">
            <summary>
            True literal.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.IsZero(Analytics.Syntactic.BaseExpression)">
            <summary>
            Checks if an expression is literal zero.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.IsUnit(Analytics.Syntactic.BaseExpression)">
            <summary>
            Checks if an expression is literal unit.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.IsNegation(Analytics.Syntactic.BaseExpression)">
            <summary>
            Checks if an expression is literal NEGATED unit.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.IsEuler(Analytics.Syntactic.BaseExpression)">
            <summary>
            Checks if an expression is literal Euler e number.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.IsPi(Analytics.Syntactic.BaseExpression)">
            <summary>
            Checks if a literal expression is Pi number.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.IsNaN(Analytics.Syntactic.BaseExpression)">
            <summary>
            Checks if a literal expression is NaN.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.IsInfinity(Analytics.Syntactic.BaseExpression)">
            <summary>
            Checks if a literal expression is Infinity.
            WARNING: POSITIVE infinity only.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.IsFalse(Analytics.Syntactic.BaseExpression)">
            <summary>
            Checks if the expression is literal False
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.IsTrue(Analytics.Syntactic.BaseExpression)">
            <summary>
            Checks if the expression is literal True
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.IsUnnamed(Analytics.Syntactic.BaseExpression)">
            <summary>
            Checks, if the expression is unnamend (nonstandard) literal.
            Supported - real and complex literals.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.IsRealValue(Analytics.Syntactic.BaseExpression,System.Double@)">
            <summary>
            Evaluates if the expression is real (nonstandard) constant value.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.Make(System.Double)">
            <summary>
            Makes literal expression for real value
            taking into account standard constants e, Pi...
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.Make(System.Numerics.Complex)">
            <summary>
            Makes literal expression for complex value.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.Make(System.Int64)">
            <summary>
            Makes literal expression for integer value.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.Make(System.Boolean)">
            <summary>
            Makes literal expression for boolean value.
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.VariableExpression">
            <summary>
            Variable
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.VariableExpression.GetPrecedence">
            <summary>
            Gets the Precedence of the expression.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.VariableExpression.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="aValue">Primary value is the name of the variable</param>
        </member>
        <member name="P:Analytics.Syntactic.VariableExpression.Name">
            <summary>
            Name of the variable
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.VariableExpression.Reconstruct">
            <summary>
            Reconstructed expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.VariableExpression.IsConstant">
            <summary>
            Variable is never constant.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.VariableExpression.DependsOn(System.String)">
            <summary>
            The expression depends on a variable.
            </summary>
            <param name="vName">Variable Name</param>
            <returns>True, if the names are the same.</returns>
        </member>
        <member name="M:Analytics.Syntactic.VariableExpression.Derivative(Analytics.Derivatives.DerivativeContext,System.String)">
            <summary>
            Calculates Expression Derivative
            </summary>
            <param name="context">Derivative Context</param>
            <param name="vName">Variable Name</param>
            <returns>Derivative expression</returns>
        </member>
        <member name="M:Analytics.Syntactic.VariableExpression.ToString">
            <summary>
            To string
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.VariableExpression.Print(System.Int32)">
            <summary>
            Print string (just for testing)
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.FunctionExpression">
            <summary>
            Function
            </summary>
        </member>
        <member name="F:Analytics.Syntactic.FunctionExpression.name">
            <summary>
            Function name
            </summary>
        </member>
        <member name="F:Analytics.Syntactic.FunctionExpression.parameters">
            <summary>
            Parameter expressions
            </summary>
        </member>
        <member name="F:Analytics.Syntactic.FunctionExpression.arguments">
            <summary>
            Argument expressions
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.FunctionExpression.GetSelfPrecedence">
            <summary>
            Gets the Precedence of the expression type.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.FunctionExpression.ReplaceInside(System.String,Analytics.Syntactic.BaseExpression)">
            <summary>
            Replaces variable by given expression inside the parameter and argument expressions.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.FunctionExpression.GetExplicit(System.Boolean)">
            <summary>
            Gets copy of the expression, expanding containing implicit arguments and parameters.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.FunctionExpression.#ctor(System.String,System.String,System.Collections.Generic.List{Analytics.Syntactic.BaseExpression},System.Collections.Generic.List{Analytics.Syntactic.BaseExpression})">
            <summary>
            Constructor
            </summary>
            <param name="aValue">Primary string</param>
            <param name="aName">Name of the function</param>
            <param name="theParameters">Parameter expressions (can be null)</param>
            <param name="theArguments">Argument expressions (can be null)</param>
        </member>
        <member name="P:Analytics.Syntactic.FunctionExpression.Name">
            <summary>
            Function name
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.FunctionExpression.ParameterCount">
            <summary>
            Parameter count
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.FunctionExpression.ArgumentCount">
            <summary>
            Argument count
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.FunctionExpression.Parameters">
            <summary>
            Function parameters
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.FunctionExpression.Arguments">
            <summary>
            Function arguments
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.FunctionExpression.Reconstruct">
            <summary>
            Reconstructed expression
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.FunctionExpression.IsConstant">
            <summary>
            Function expression is constant if all arguments and parameters are.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.FunctionExpression.DependsOn(System.String)">
            <summary>
            The expression depends on a variable.
            </summary>
            <param name="vName">Variable Name</param>
            <returns>True, if depends</returns>
        </member>
        <member name="M:Analytics.Syntactic.FunctionExpression.Simplify">
            <summary>
            Simplifies all parameters and arguments
            (standard functions properties are not taket into account)
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.FunctionExpression.Derivative(Analytics.Derivatives.DerivativeContext,System.String)">
            <summary>
            Calculates Functional Expression Derivative
            </summary>
            <param name="context">Derivative Context</param>
            <param name="vName">Variable Name</param>
            <returns>Derivative expression</returns>
        </member>
        <member name="M:Analytics.Syntactic.FunctionExpression.ToString">
            <summary>
            To string
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.FunctionExpression.Print(System.Int32)">
            <summary>
            Print string (just for testing)
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.FunctionExpression.CreateSimple(System.String,Analytics.Syntactic.BaseExpression)">
            <summary>
            Creates simple function expression with one argument and given name.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.FunctionExpression.CreateBinary(System.String,Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression)">
            <summary>
            Creates binary function expression with two arguments and given name.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.FunctionExpression.CreateParametric(System.String,Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression)">
            <summary>
            Creates parametric function expression with one parameter, one argument and given name.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.FunctionExpression.CreateBinaryParametric(System.String,Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression)">
            <summary>
            Creates binary parametric function expression with one parameter, two arguments and given name.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.FunctionExpression.CreateBiparametric(System.String,Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression)">
            <summary>
            Creates biparametric function expression with two parameters, one argument and given name.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.FunctionExpression.CreateBinaryBiparametric(System.String,Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression)">
            <summary>
            Creates binary biparametric function expression with two parameters, two arguments and given name.
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.UnaryOperatorExpression">
            <summary>
            Unary operator expression: operator + operand
            </summary>
        </member>
        <member name="F:Analytics.Syntactic.UnaryOperatorExpression.sign">
            <summary>
            Operator sign
            </summary>
        </member>
        <member name="F:Analytics.Syntactic.UnaryOperatorExpression.position">
            <summary>
            Operator position
            </summary>
        </member>
        <member name="F:Analytics.Syntactic.UnaryOperatorExpression.operand">
            <summary>
            Operand
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.UnaryOperatorExpression.GetSelfPrecedence">
            <summary>
            Precedence of the operator (based on Operator)
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.UnaryOperatorExpression.Degenerate">
            <summary>
            Degenerates the expression
            (assigns sign = "")
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.UnaryOperatorExpression.ReplaceInside(System.String,Analytics.Syntactic.BaseExpression)">
            <summary>
            Replaces variable by given expression inside the operand expression.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.UnaryOperatorExpression.GetExplicit(System.Boolean)">
            <summary>
            Gets copy of the expression, expanding implicit operand.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.UnaryOperatorExpression.MergeDegenerated">
            <summary>
            Merges degenerated operand (replace it with its operand).
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.UnaryOperatorExpression.#ctor(System.String,System.String,Analytics.OperatorPosition,Analytics.Syntactic.BaseExpression)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.UnaryOperatorExpression.Sign">
            <summary>
            Operator sign
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.UnaryOperatorExpression.Operator">
            <summary>
            Gets operator type (based on Sign).
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.UnaryOperatorExpression.Position">
            <summary>
            Position
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.UnaryOperatorExpression.Operand">
            <summary>
            Operand
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.UnaryOperatorExpression.IsDegenerated">
            <summary>
            Checks if the Unary operator expression is degenerated
            (contains no operation but operand only).
            It may happen after simplification procedure.
            If the operation is degenerated its VALUE is just the OPERAND's value.
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.UnaryOperatorExpression.Degenerated">
            <summary>
            Returns the operand.
            WARNING: DOES NOT check if the expression is degenerated.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.UnaryOperatorExpression.MustEnclose(Analytics.Syntactic.BaseExpression)">
            <summary>
            Checks if the operand must be eclosed with parentheses.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.UnaryOperatorExpression.Reconstruct">
            <summary>
            Reconstructed string
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.UnaryOperatorExpression.IsConstant">
            <summary>
            Unary operation is constant if the operand is.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.UnaryOperatorExpression.DependsOn(System.String)">
            <summary>
            The expression depends on a variable.
            </summary>
            <param name="vName">Variable Name</param>
            <returns>True, if depends</returns>
        </member>
        <member name="M:Analytics.Syntactic.UnaryOperatorExpression.Derivative(Analytics.Derivatives.DerivativeContext,System.String)">
            <summary>
            Calculates Expression Derivative
            (WARNING: NOT defined for some operators and can throw the exception)
            </summary>
            <param name="context">Derivative Context</param>
            <param name="vName">Variable Name</param>
            <returns>Derivative expression</returns>
        </member>
        <member name="M:Analytics.Syntactic.UnaryOperatorExpression.SqrtDerivative(Analytics.Syntactic.BaseExpression,Analytics.Derivatives.DerivativeContext,System.String)">
            <summary>
            Calculates derivative of square root of operand in the form of prefix SQRT operator.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.UnaryOperatorExpression.Negate(Analytics.Syntactic.BaseExpression)">
            <summary>
            Negates an expression.
            NOTE: Uses equality -(-x) = x
                                -0 = 0
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.UnaryOperatorExpression.Sqrt(Analytics.Syntactic.BaseExpression)">
            <summary>
            Makes square root expression of the value in the form of SQRT prefix operator.
            NOTE: uses some simplifications SQRT(0) = 0, SQRT(1) = 1, SQRT(infinity) = infinity, SQRT(NaN) = NaN.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.UnaryOperatorExpression.Factorial(Analytics.Syntactic.BaseExpression)">
            <summary>
            Makes factorial expression of the value.
            NOTE: uses some simplifications 0! = 1, 1! = 1, infinity! = infinity, NaN! = NaN.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.UnaryOperatorExpression.Abs(Analytics.Syntactic.BaseExpression)">
            <summary>
            Makes absolute expression of the value.
            NOTE: uses some simplifications |0| = 0, |1| = 1, |infinity| = infinity, |NaN| = NaN.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.UnaryOperatorExpression.IsNegation(Analytics.Syntactic.BaseExpression)">
            <summary>
            Checks if an expression is NEGATED literal unit.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.UnaryOperatorExpression.Simplify">
            <summary>
            Simplifies operand then uses the following rules:
            1. -0 = 0, -(-x) = x
            2. 0! = 1, 1!=1 infinity! = infinity, NaN! = NaN
            3. ¬True = False, ¬False = true
            4. Square root of 0, 1, Infinity or NaN is the operand value, extracts positive integer root values.
            5. |-x| = |x|, Absolute of 0, 1, Infinity or NaN is the operand value, extracts real values.
            6. Put Minus operator under sum or product operands.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.UnaryOperatorExpression.ToString">
            <summary>
            To string
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.UnaryOperatorExpression.Print(System.Int32)">
            <summary>
            Print string (just for testing)
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.UnaryOperatorExpression.IsUnary(Analytics.Syntactic.BaseExpression,Analytics.OperatorType)">
            <summary>
            Checks if an expression is unary one of specified operator type.
            </summary>
            <param name="expr">Expression</param>
            <param name="t">Operator type</param>
            <returns>True if is</returns>
        </member>
        <member name="T:Analytics.Syntactic.BinaryOperationsExpression">
            <summary>
            A sequence of Binary Operations Expression
            operand1 x operand2 x ... x operandN
            The operator count must equal operand count - 1.
            </summary>
        </member>
        <member name="F:Analytics.Syntactic.BinaryOperationsExpression.operators">
            <summary>
            Operator signs
            </summary>
        </member>
        <member name="F:Analytics.Syntactic.BinaryOperationsExpression.operands">
            <summary>
            Operand expressions
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.GetSelfPrecedence">
            <summary>
            Precedence of the operator sequence
            (because all operators in the sequence must have equal precedence)
            Default implementation is based on the first operator,
            can be overriden in descendant classes.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.ReplaceInside(System.String,Analytics.Syntactic.BaseExpression)">
            <summary>
            Replaces variable by given expression inside the operand expressions.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.GetExplicit(System.Boolean)">
            <summary>
            Gets copy of the expression, expanding implicit operands.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.GetRealValues(System.Boolean[]@,System.Double[]@)">
            <summary>
            Gets operands as real values (nonstandard constants).
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.GetBinaryType">
            <summary>
            Returns binary operation type
            (default implementation based on the first operator in 
            the expression, can be overriden in descendant classes).
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.Degenerate">
            <summary>
            Degenerates the binary expression - clears all operators
            and REMOVES all operands except the first.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.SimplifyOperands">
            <summary>
            Simplifies all operands
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.MergeDegenerated">
            <summary>
            Merges degenerated operands (replace them with their operands).
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.MergeOperands">
            <summary>
            Merges all operands (does nothing by default, must be overriden).
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.SimplifyBase">
            <summary>
            Simplifies expression using base rules (does nothing by default, must be overriden).
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.MergeConstants">
            <summary>
            Merges all nonstandard constants (does nothing by default, must be overriden).
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.InsertOperationLeft(System.Int32,System.String,Analytics.Syntactic.BaseExpression)">
            <summary>
            Insert operation before specified operand.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.InsertOperationRight(System.Int32,System.String,Analytics.Syntactic.BaseExpression)">
            <summary>
            Insert operation after specified operand.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.RemoveOperationLeft(System.Int32)">
            <summary>
            Removes operation with its LEFT operand.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.RemoveOperationRight(System.Int32)">
            <summary>
            Removes operation with its RIGHT operand.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.ClearOperations">
            <summary>
            Just removes all operators and operands.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.#ctor(System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.List{Analytics.Syntactic.BaseExpression})">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.BinaryOperationsExpression.OperationCount">
            <summary>
            Operation count
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.BinaryOperationsExpression.IsDegenerated">
            <summary>
            Checks if the binary operations expression is degenerated
            (contains one operand and no operation).
            If true, it can be replaced by Operands[0] expression.
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.BinaryOperationsExpression.Degenerated">
            <summary>
            Returns the first operand.
            WARNING: DOES NOT check if the expression is degenerated.
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.BinaryOperationsExpression.BinaryType">
            <summary>
            Type of binary expression.
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.BinaryOperationsExpression.Operators">
            <summary>
            Operator signs
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.BinaryOperationsExpression.Operands">
            <summary>
            Operand expressions
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.MustEnclose(System.Int32,Analytics.Syntactic.BaseExpression)">
            <summary>
            Checks if the operand with specified position must be eclosed with parentheses.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.Reconstruct">
            <summary>
            Reconstructed expression
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.IsConstant">
            <summary>
            Binary operation sequence is constant if all the operands are.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.DependsOn(System.String)">
            <summary>
            The expression depends on a variable.
            </summary>
            <param name="vName">Variable Name</param>
            <returns>True, if depends</returns>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.Simplify">
            <summary>
            Default binary operation simplification algorithm -
            simplify operands, merges degenerated and then merge operations,
            simplify with base rules and then merge nonstandard constants.
            WARNING: expression can be degenerated after simplification.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.MakeBinary(Analytics.BinaryOperationType,System.Collections.Generic.List{Analytics.Syntactic.BaseExpression},System.Collections.Generic.List{System.String})">
            <summary>
            Makes binary expression with binary operators of the same type.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.MakeBinary(System.Collections.Generic.List{Analytics.Syntactic.BaseExpression},System.String)">
            <summary>
            Makes binary expression with the same operator (sign).
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.ToString">
            <summary>
            To string
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.Print(System.Int32)">
            <summary>
            Print string (just for testing)
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.LogicalExpression">
            <summary>
            Logical binary expression.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.LogicalExpression.GetSelfPrecedence">
            <summary>
            Precedence of the logical operator sequence
            (based on the 'and' operator precedence).
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.LogicalExpression.GetBinaryType">
            <summary>
            Returns binary operation type - Logical
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.LogicalExpression.#ctor(System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.List{Analytics.Syntactic.BaseExpression})">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.LogicalExpression.Derivative(Analytics.Derivatives.DerivativeContext,System.String)">
            <summary>
            Logical expression derivative - defined for constant expression only.
            </summary>
            <param name="context">Derivative Context</param>
            <param name="vName"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.LogicalExpression.Simplify">
            <summary>
            Simplifies logical expression (operands only).
            TODO: simplify using standard logical identities
                  (CAN WE DO THIS - if the logical operators are
                   overloaded for some type we cannot use standard
                   logical rules for them)
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.RelationalExpression">
            <summary>
            Relational binary expression.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.RelationalExpression.GetSelfPrecedence">
            <summary>
            Precedence of the Relational operator sequence
            (based on the '>' operator precedence).
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.RelationalExpression.GetBinaryType">
            <summary>
            Returns binary operation type - Relational
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.RelationalExpression.#ctor(System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.List{Analytics.Syntactic.BaseExpression})">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.RelationalExpression.Derivative(Analytics.Derivatives.DerivativeContext,System.String)">
            <summary>
            Relational expression derivative - defined for constant expression only.
            </summary>
            <param name="context">Derivative Context</param>
            <param name="vName"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.RelationalExpression.Simplify">
            <summary>
            Simplifies logical expression (operands only).
            TODO: simplify using standard logical identities.
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.SumExpression">
            <summary>
            Sum binary expression.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.SumExpression.GetSelfPrecedence">
            <summary>
            Precedence of the SUM operator sequence
            (based on the '+' operator precedence).
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.SumExpression.GetBinaryType">
            <summary>
            Returns binary operation type - Sum
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.SumExpression.MergeOperands">
            <summary>
            Merges the operands:
            1. Sum expressions: 1-(2-x).
            2. Minus expressions: 1+(-x).
            3. Product expressions with minus: y+(-2*x)
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.SumExpression.SimplifyBase">
            <summary>
            Simplifies the sum expression using the following rules:
            1. Sums same operand expressions: x+A+x -> 2*x+A.
            2. Removing all zero items.
            3. If the first operand is 0 - negates the second one.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.SumExpression.#ctor(System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.List{Analytics.Syntactic.BaseExpression})">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.SumExpression.Derivative(Analytics.Derivatives.DerivativeContext,System.String)">
            <summary>
            Sum expression derivative.
            </summary>
            <param name="context">Derivative Context</param>
            <param name="vName"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.SumExpression.Negate">
            <summary>
            Negates this sum expression
            (negates first operand and then inverses all operations).
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.SumExpression.MakeSum(Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression)">
            <summary>
            Makes sum of two operands x1+x2.
            Simplifies result using equalities: 
            0+x2 = x2
            x1+0 = x1
            (-x1)+(-x2) = -(x1+x2)
            x1+(-x2) = x1-x2
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.SumExpression.MakeDifference(Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression)">
            <summary>
            Makes difference of two operands x1-x2.
            Simplifies result using equalities: 
            x1-0 = x1
            0-x2 =-x2
            x1-(-x2) = x1+x2
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.ProductExpression">
            <summary>
            Product binary expression.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.ProductExpression.GetSelfPrecedence">
            <summary>
            Precedence of the PRODUCT operator sequence
            (based on the '*' operator precedence).
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.ProductExpression.GetBinaryType">
            <summary>
            Returns binary operation type - Product
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.ProductExpression.Decompose(System.Collections.Generic.List{Analytics.Syntactic.BaseExpression}@,System.Collections.Generic.List{Analytics.Syntactic.BaseExpression}@,System.Collections.Generic.List{System.String}@,System.Collections.Generic.List{System.String}@)">
            <summary>
            Extracts from product expression x1*x2/x3*x4*x5/x6...
            numerator (x1,x2,x4,x5...) and denominator (x3,x6...) expressions.
            NOTE: out operators are multiplication ones (Multiply, Dot or Cross).
            NOTE: denominator operators are always of Multiply type (*)
                  because it is inverse of Divide operation.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.ProductExpression.#ctor(System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.List{Analytics.Syntactic.BaseExpression})">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.ProductExpression.IsInvertible">
            <summary>
            The product expressions can be inverted.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.ProductExpression.ToFraction">
            <summary>
            Converts product expression x1*x2/x3*x4*x5/x6...  
            to equivalent 'fraction' expression n/d, where n=(x1,x2,x4,x5...) d=(x3,x6...)
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.ProductExpression.Derivative(Analytics.Derivatives.DerivativeContext,System.String)">
            <summary>
            Product expression derivative.
            (decomposes the expression into numerator and denominator expressions,
            if there is no denominator - calculates 'pure product' derivative,
            else - calculates fraction derivative).
            </summary>
            <param name="context">Derivative Context</param>
            <param name="vName"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.ProductExpression.MergeOperands">
            <summary>
            Merges the operands:
            1. Product expressions: 2*(2*x).
            2. Minus operations and negative constants: (A+B)*(-x)*(-y)
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.ProductExpression.SimplifyBase">
             <summary>
             Simplifies the product expression using the following rules:
             1. Removing all unit items.
             2. If there are more 0 in numerator than in denominator then = 0.
             3. Finds the same expressions in the numerator and in the denominator and reduces them.
             NOTE: Minus expressions and their pairs reduction realized in MergeOperands.
            
             WARNING: current method implementation can change the order of multiplication/division
                      that can lead to errors for Vector/Matrix operations.
             </summary>
        </member>
        <member name="M:Analytics.Syntactic.ProductExpression.MergeSpecialConst">
             <summary>
             Special case of constant merge with -1: (-1)*(A-B) = -A+B
             (works for Sum, Variable, Indexing and Functions
             TODO: use for other expressions?)
            
             if TRUE - the expression is degenerated
             </summary>
        </member>
        <member name="M:Analytics.Syntactic.ProductExpression.ProductDerivative(System.Collections.Generic.List{Analytics.Syntactic.BaseExpression},System.Collections.Generic.List{System.String},Analytics.Derivatives.DerivativeContext,System.String)">
            <summary>
            Calculates product derivative.
            (x1*x2*x3*...*xn)' = x1'*x2*x3*...*xn+x1*x2'*x3*...*xn+...
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.ProductExpression.DivisionDerivative(Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression,Analytics.Derivatives.DerivativeContext,System.String)">
            <summary>
            Calculates division expression derivative (n/d)'.
            (n/d)' = (n'd-nd')/d^2
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.ProductExpression.Negate">
            <summary>
            Negates this product expression
            (negates first operand).
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.ProductExpression.MakeProduct(Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression)">
            <summary>
            Makes product of two operands x1*x2.
            Simplifies result using equalities: 
            NaN*x2 or x1*NaN = NaN
            0*x2 = 0, x2 is not Infinity
            x1*0 = 0, x1 is not Infinity
            1*x2 = x2
            x1*1 = x1
            -1*x2 = -x2
            x1*(-1) = -x1
            WARNING: positive infinity only.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.ProductExpression.MakeDivision(Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression)">
            <summary>
            Makes division of two operands x1/x2.
            Simplifies result using equalities: 
            NaN/x2 or x1/NaN = NaN
            x1/1 = x1
            0/x2 = 0, x2 is not zero
            x1/(-1) = -x1
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.ProductExpression.SimplifyProduct(System.Collections.Generic.List{Analytics.Syntactic.BaseExpression})">
            <summary>
            Makes simplified expression from a sequence of products x1*x2*...*xn.
            (sequentially applies MakeProduct method to multipliers).
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.ProductExpression.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.ProductExpression.OneHalf">
            <summary>
            1/2.
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.ProductExpression.OneThird">
            <summary>
            1/3.
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.PowerExpression">
            <summary>
            Power binary expression.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.PowerExpression.GetSelfPrecedence">
            <summary>
            Precedence of the POWER operator sequence
            (based on the '^' operator precedence).
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.PowerExpression.GetBinaryType">
            <summary>
            Returns binary operation type - Power
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.PowerExpression.#ctor(System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.List{Analytics.Syntactic.BaseExpression})">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.PowerExpression.ToHierarchical">
            <summary>
            Makes equivalent hierarchical power expression from the sequence of power operations.
            f1(x)^f2(x)^..^fn(x) = ((f1(x)^f2(x))^f3(x))^..)^fn(x).
            NOTE: left assosiativity assumed!
            WARNING: Works only for operand count >= 2.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.PowerExpression.Derivative(Analytics.Derivatives.DerivativeContext,System.String)">
            <summary>
            Power (sequence) derivative (f1(x)^f2(x)^..^fn(x))'.
            Recursive implementation. For two operands direct formula (f(x)^g(x))' used,
            for more operands the sequence is converted into equivalent hierarchical power expression.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.PowerExpression.MergeOperands">
            <summary>
            First power operand merged (recursively):
            (x^y)^z == x^y^z
            x^(y^z) != x^y^z (by the rule of left associativity).
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.PowerExpression.SimplifyBase">
            <summary>
            Simplifies power expression.
            Uses the following equalities:
            1. f1(x)^f2(x)^...^0^...^fn(x) = 1
            (if there is a 0 power - the result is 1 because when the 0 power applied
             all before it becomes 1 and see 2)
            2. (1)^f1(x)^f2(x)^...^fn(x) = 1 
               (if the first operand is unit - result is always unit)
            3. f1(x)^1^f2(x)^f3(x)^1^f4(x)^...=f1(x)^f2(x)^f3(x)^f4(x)^...
               (all unit powers can be just removed)
            4. 0^f1(x)^f2(x)... - MUST NOT be simplified to 0, even if there is no zero powers.
                                  The result value depends on the function values and can be
                                  defined after calculation only.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.PowerExpression.PowerDerivative(Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression,Analytics.Derivatives.DerivativeContext,System.String)">
            <summary>
            Calculates power derivative (f(x)^g(x))'.
            There are three main cases:
            1. f=const. (f^g(x))' = ln(f)*f^g(x)*g'(x), (1^g(x))' = 0.
            2. g=const (f(x)^g)' = g*f(x)^(g-1)*f'(x), g is not 0.
            3. (f(x)^g(x))' = ln(f(x))*f(x)^g(x)*g'(x)+g(x)*f(x)^(g(x)-1)*f'(x)
            (=const means that it does not depend on variable x)
            </summary>
            <param name="f">Value f(x)</param>
            <param name="g">Power g(x)</param>
            <param name="context"></param>
            <param name="vName"></param>
            <returns>Derivative Expression</returns>
        </member>
        <member name="M:Analytics.Syntactic.PowerExpression.MakePower(Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression)">
            <summary>
            Makes power expression x^y.
            NOTE: uses some simplifications x^1 = x, x^0 = 1, 1^y = 1.
            WARNING: now x^0 is always 1, no matter if x is Infinite!
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.PowerExpression.MakeSquare(Analytics.Syntactic.BaseExpression)">
            <summary>
            Makes square expression of the value.
            NOTE: uses some simplifications 0^2 = 0, 1^2 = 1, infinity^2 = infinity, NaN^2 = NaN.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.PowerExpression.MakeSquareRoot(Analytics.Syntactic.BaseExpression)">
            <summary>
            Makes square root expression of the value in the form of POWER (1/2).
            NOTE: uses some simplifications 0^(1/2) = 0, 1^(1/2) = 1, infinity^(1/2) = infinity, NaN^(1/2) = NaN.
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.ArrowExpression">
            <summary>
            Arrow binary expression.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.ArrowExpression.GetSelfPrecedence">
            <summary>
            Precedence of the Arrow operator sequence
            (based on the 'left arrow' operator precedence).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.ArrowExpression.GetBinaryType">
            <summary>
            Returns binary operation type - Arrow
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.ArrowExpression.#ctor(System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.List{Analytics.Syntactic.BaseExpression})">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.ArrowExpression.Derivative(Analytics.Derivatives.DerivativeContext,System.String)">
            <summary>
            Arrow (sequence) derivative is defined for constant expression only.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.ArrowExpression.Simplify">
            <summary>
            Simplifies operands only.
            There are no other simplification rules because
            the sense of the operators can be different.
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.SyntaxRuleFunction">
            <summary>
            Syntax Rule delegate
            </summary>
            <returns>True, if the rule is fulfilled, syntax error if not</returns>
        </member>
        <member name="T:Analytics.Syntactic.SyntaxRule">
            <summary>
            Syntax rule class.
            Contains syntax rule function and its characteristics.
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.SyntaxRule.RuleFunction">
            <summary>
            Function
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.CharacterRule">
            <summary>
            A 'rule' for some character in a string.
            </summary>
            <param name="value">String value</param>
            <param name="index">The character index in the string value</param>
            <returns>True, if the rule is fulfilled</returns>
        </member>
        <member name="T:Analytics.Syntactic.CharacterRuleSet">
            <summary>
            Character rule set
            </summary>
        </member>
        <member name="F:Analytics.Syntactic.CharacterRuleSet.rules">
            <summary>
            Rules
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.CharacterRuleSet.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.CharacterRuleSet.SetRule(System.Char,Analytics.Syntactic.CharacterRule)">
            <summary>
            Sets new rule for a character
            (if there are rules for a character - adds it to the list,
            else creates new list for the character)
            </summary>
            <param name="character"></param>
            <param name="rule"></param>
        </member>
        <member name="M:Analytics.Syntactic.CharacterRuleSet.CheckRules(System.Char,System.String,System.Int32)">
            <summary>
            Checks if ALL rules are fulfilled for a character.
            </summary>
            <param name="symbol"></param>
            <param name="value"></param>
            <param name="index"></param>
            <returns>True, if all rules returne true or no rule exists</returns>
        </member>
        <member name="T:Analytics.Syntactic.SyntaxError">
            <summary>
            Syntax Error base class
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.SyntaxError.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.SyntaxError.Description">
            <summary>
            Error Description
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.SyntaxError.Primary">
            <summary>
            Primary string
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.SyntaxError.Position1">
            <summary>
            First position
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.SyntaxError.Position2">
            <summary>
            Second position
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.ParanthesisError">
            <summary>
            Paranthesis Error base class
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.ParanthesisError.#ctor(System.String,System.Int32,System.Int32,Analytics.Syntactic.SymbolPair)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.UnexpectedParanthesis">
            <summary>
            Unexpected (closing) paranthesis error.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.UnexpectedParanthesis.#ctor(System.String,System.Int32,System.Int32,Analytics.Syntactic.SymbolPair)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.ParanthesisExpected">
            <summary>
            Paranthesis (closing) expected.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.ParanthesisExpected.#ctor(System.String,System.Int32,System.Int32,Analytics.Syntactic.SymbolPair)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.ParanthesisExpectedButFound">
            <summary>
            Paranthesis (closing) expected but another found.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.ParanthesisExpectedButFound.#ctor(System.String,System.Int32,System.Int32,Analytics.Syntactic.SymbolPair)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.SymbolParityError">
            <summary>
            Symbol Parity Error base class
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.SymbolParityError.#ctor(System.String,System.Int32,System.Int32,Analytics.Syntactic.SymbolPair)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.ParanthesisMustBeClosedError">
            <summary>
            Paranthesis not closed befor parity symbol.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.ParanthesisMustBeClosedError.#ctor(System.String,System.Int32,System.Int32,Analytics.Syntactic.SymbolPair)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.ClosingSymbolParityError">
            <summary>
            Closing Symbol parity error.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.ClosingSymbolParityError.#ctor(System.String,System.Int32,System.Int32,Analytics.Syntactic.SymbolPair)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.InvalidConstructionError">
            <summary>
            Invalid Construction base class
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.InvalidConstructionError.#ctor(System.String,System.Int32,System.Int32,System.String)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.InvalidSymbolError">
            <summary>
            Invalid Symbol base class
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.InvalidSymbolError.#ctor(System.String,System.Int32,System.Char)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.InvalidBeginSymbolError">
            <summary>
            Invalid Begin Symbol
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.InvalidBeginSymbolError.#ctor(System.String,System.Int32,System.Char)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.InvalidEndSymbolError">
            <summary>
            Invalid End Symbol
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.InvalidEndSymbolError.#ctor(System.String,System.Int32,System.Char)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.PairErrorData">
            <summary>
            Pair (of symbols) error data
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.Builder">
            <summary>
            Syntactic Expression builder.
            Realizes methods for building complex (string) expressions
            from simplier (string) ones following syntax rules.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Builder.Surround(System.String,Analytics.Syntactic.SymbolPair,System.Boolean)">
            <summary>
            Surrounds a string by a pair of symbols
            </summary>
            <param name="value">String value</param>
            <param name="bounds">Symbols to surround with</param>
            <param name="empty">Must empty string be surrounded</param>
            <returns>Surrounded string (or empty string)</returns>
        </member>
        <member name="M:Analytics.Syntactic.Builder.MakeList(System.Collections.Generic.List{System.String},System.String)">
            <summary>
            Makes list expression (items separated by a separator)
            </summary>
            <param name="values">Items</param>
            <param name="separator">Separator</param>
            <returns>String value</returns>
        </member>
        <member name="M:Analytics.Syntactic.Builder.MakeList(System.String,System.String,System.Int32,System.Boolean)">
            <summary>
            Makes list of same expression (items separated by a separator)
            </summary>
            <param name="value">Expression</param>
            <param name="separator">Separator</param>
            <param name="count">Count of values</param>
            <param name="addNumber">Add the number of expression</param>
            <returns>String value</returns>
        </member>
        <member name="M:Analytics.Syntactic.Builder.MakeList(System.String,System.Int32,System.Boolean)">
            <summary>
            Makes list of same expression
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Builder.MakeList(System.Collections.Generic.List{System.String},System.String,Analytics.Syntactic.SymbolPair,System.Boolean)">
            <summary>
            Makes list expression and surrounds it by a pair of symbols
            </summary>
            <param name="values">Items</param>
            <param name="separator">Separator</param>
            <param name="bounds">Symbols to surround with</param>
            <param name="empty">Must an empty value be surrounded</param>
            <returns>String value</returns>
        </member>
        <member name="M:Analytics.Syntactic.Builder.MakeMultilist(System.Collections.Generic.List{System.String},Analytics.Syntactic.SymbolPair)">
            <summary>
            Makes multilist expression - a sequence of items surrounded by a symbol pair
            (empty items are surrounded by symbols too)
            </summary>
            <param name="values">Items</param>
            <param name="bounds">Symbols to surround with</param>
            <returns>String value</returns>
        </member>
        <member name="M:Analytics.Syntactic.Builder.BuildArrayIndexes(System.Collections.Generic.List{System.String})">
            <summary>
            Builds an array index expression
            </summary>
            <param name="indexes">Indexes</param>
            <returns>Array index expression</returns>
        </member>
        <member name="M:Analytics.Syntactic.Builder.BuildFunctionParameters(System.Collections.Generic.List{System.String})">
            <summary>
            Builds a function parameters expression
            </summary>
            <param name="parameters">Parameters</param>
            <returns>Function parameters expression (can be empty string)</returns>
        </member>
        <member name="M:Analytics.Syntactic.Builder.BuildFunctionArguments(System.Collections.Generic.List{System.String})">
            <summary>
            Builds a function arguments expression
            </summary>
            <param name="arguments">Arguments</param>
            <returns>Function arguments expression (cannot be empty string)</returns>
        </member>
        <member name="M:Analytics.Syntactic.Builder.BuildArrayItem(System.String,System.Collections.Generic.List{System.String})">
            <summary>
            Builds an array expression
            </summary>
            <param name="name">Array name</param>
            <param name="indexes">Indexes</param>
            <returns>Array expression</returns>
        </member>
        <member name="M:Analytics.Syntactic.Builder.BuildFunction(System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.String})">
            <summary>
            Builds a function expression
            </summary>
            <param name="name">Function name</param>
            <param name="parameters">Parameters</param>
            <param name="arguments">Arguments</param>
            <returns>Function expression</returns>
        </member>
        <member name="M:Analytics.Syntactic.Builder.BuildUnaryOperation(System.String,System.String,Analytics.OperatorPosition,System.Boolean)">
            <summary>
            Builds unary operation expression
            </summary>
            <param name="op"></param>
            <param name="operand"></param>
            <param name="position"></param>
            <param name="enclose">Enclose operand by parantheses</param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.Builder.BuildBinaryOperations(System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.Boolean})">
            <summary>
            Builds binary operations expression.
            Tne operator count must be equal to the operand count - 1.
            </summary>
            <param name="operands"></param>
            <param name="operators"></param>
            <param name="enclose">Enclose operands by parantheses</param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.Builder.BuildVector(System.String[])">
            <summary>
            Builds a vector expression
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Builder.BuildMatrix(System.String[],System.Int32,System.Int32)">
            <summary>
            Builds a matrix expression
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Builder.BuildDerivative(System.String,System.Boolean,System.String[],System.Int32[])">
            <summary>
            Builds derivative expression
            d'Superscript Digit'(Operand)/dX1'Superscript Digit'dX2'Superscript Digit'...dXN'Superscript Digit'
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Builder.BuildIntegral(System.String,System.String,System.Boolean)">
            <summary>
            Builds integral expression
            I'Operand'dX
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.BaseExpression">
            <summary>
            Base abstract class for all Expressions.
            
            All expressions devided by two categories:
            1. Simple expressions (do not contain other expressions).
            2. Structured expressions (those are built with other expressions using operators, functions and indexes).
            There are the following expressions:
            Simple:
            - literals (constant values with no name or symbols staying for ‘standard’ constant values Pi, e and so on)
            - variables (named data, including named constants)
            Structured:
            - indexing (named indexed data)
            - functions (name, parameters and arguments)
            - operations (operators and operands)
            - array (vector/matrix expressions, containing other expressions as items)
            There are unary and binary operations.
            Unary operation contains one operator and one operand (another expression).
            Binary operations are combined into sequences of operators of one precedence
            (for an example, a sequence of product (*,/) operations).
            All unary operators have higher precedence than binary,
            postfix operators have higher precedence than prefix ones.
            WARNING: If all unary operators have higher precedence than 
                     binary ones, then some expressions with 'minus' operator have
                     not 'mathematical' meaning. '-x^y' means (-x)^(y), not 'math' -(x^y).
                     But x^-y has 'mathematical' meaning only if '-' has higher precedence than '^'.
            WARNING: All binary operators are assumed to be 'left-associative', this means that
                     all sequences of same operators are calculated from left to right.
                     This leads the power operations '^' considered as the following:
                     2^3^2 means (2^3)^2, NOT 2^(3^2).
            </summary>
        </member>
        <member name="F:Analytics.Syntactic.BaseExpression.value">
            <summary>
            Primary String value from wich the expression is created
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.GetValue">
            <summary>
            Gets value if defined, or reconstructed if the primary is undefined
            (for internal use only - to string, Print ...)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.GetPrecedence">
            <summary>
            Gets the Precedence of the expression.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.BaseExpression.PrimaryValue">
            <summary>
            Primary value
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.BaseExpression.Precedence">
            <summary>
            Precedence of the expression.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.Reconstruct">
            <summary>
            Reconstructs the expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.IsConstant">
            <summary>
            Expression is constant.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.DependsOn(System.String)">
            <summary>
            The expression depends on a variable.
            </summary>
            <param name="vName">Variable Name</param>
            <returns>True, if depends</returns>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.Derivative(Analytics.Derivatives.DerivativeContext,System.String)">
            <summary>
            Calculates Expression Derivative
            (not abstract to define default behaviour - exception)
            </summary>
            <param name="context">Derivative Context</param>
            <param name="vName">Variable Name</param>
            <returns>Derivative expression</returns>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.Simplify">
            <summary>
            Simplifies the expression.
            (does nothing by default, must be overriden in specific classes)
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.Copy(System.Boolean)">
            <summary>
            Makes a copy of the expression, can make simplification at once.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.Print(System.Int32)">
            <summary>
            Print string (just for testing)
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.CreateBinaryExpression(System.String,Analytics.BinaryOperationType,System.Collections.Generic.List{System.String},System.Collections.Generic.List{Analytics.Syntactic.BaseExpression})">
            <summary>
            Creates binary expression of the specified type.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.Build(System.String)">
            <summary>
            Builds an expression from the string value (recursive).
            </summary>
            <param name="value">String value</param>
            <returns>Built expression, null or throws an exception</returns>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.ExplicitExpression(Analytics.Syntactic.BaseExpression,System.Boolean)">
            <summary>
            Creates copy of the expression and expands implicit operations.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.BuildList(System.Collections.Generic.List{System.String})">
            <summary>
            Builds a list of expressions.
            </summary>
            <param name="values">String values (can be null)</param>
            <returns>Built expressions (can return null for null value list)</returns>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.BuildArray(System.String[])">
            <summary>
            Builds array of expressions.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.MergeDegenerated(System.Collections.Generic.List{Analytics.Syntactic.BaseExpression})">
            <summary>
            Changes degenerated unary and binary expressions by their Operands.
            </summary>
            <param name="expressions"></param>
            <returns>The number of changes made</returns>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.SimplifyList(System.Collections.Generic.List{Analytics.Syntactic.BaseExpression},System.Boolean)">
            <summary>
            Simplifies all items in the list.
            </summary>
            <param name="expressions"></param>
            <param name="mergeDegenerated">Merge degenerated binary expressions after simplification</param>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.GetPrimaries(System.Collections.Generic.List{Analytics.Syntactic.BaseExpression})">
            <summary>
            Gets the list of expression primary values
            </summary>
            <param name="expressions"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.GetReconstructed(System.Collections.Generic.List{Analytics.Syntactic.BaseExpression})">
            <summary>
            Gets the list of reconstructed expressions
            </summary>
            <param name="expressions"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.GetVariableNames(Analytics.Syntactic.BaseExpression,System.Collections.Generic.List{System.String})">
            <summary>
            Gets the list of variable names 
            NOTE: the result contains only variable names explicitly presented in symbolic expression,
                  it does not substitute variables and evaluates imlicit operations.
            NOTE: the method is recursive and adds the names to the initial list.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.IsDependant(System.Collections.Generic.List{Analytics.Syntactic.BaseExpression},System.String)">
            <summary>
            Checks if the list of expressions depend on a variable.
            </summary>
            <param name="expressions">Expressions</param>
            <param name="vName">Variable name</param>
            <returns>True, if at least one depends</returns>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.Derivatives(System.Collections.Generic.List{Analytics.Syntactic.BaseExpression},Analytics.Derivatives.DerivativeContext,System.String)">
            <summary>
            Calculates derivatives of the expression list.
            </summary>
            <param name="expressions">Expressions (can be null)</param>
            <param name="context">Derivative context</param>
            <param name="vName">Variable Name</param>
            <returns>Derivatives of the expressions or null.</returns>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.AreConstant(System.Collections.Generic.List{Analytics.Syntactic.BaseExpression})">
            <summary>
            Checks if all the expressions are constant.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.RemoveSame(System.Collections.Generic.List{Analytics.Syntactic.BaseExpression},System.Collections.Generic.List{Analytics.Syntactic.BaseExpression},System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.String})">
            <summary>
            Removes the same (exactly) expressions from the lists
            (one by one from each list).
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.FindCount(System.Collections.Generic.List{Analytics.Syntactic.BaseExpression},Analytics.Syntactic.BaseExpression)">
            <summary>
            Finds count of the same expresions in the list.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.op_UnaryNegation(Analytics.Syntactic.BaseExpression)">
            <summary>
            Unary minus operator
            </summary>
            <param name="expr">Expression</param>
            <returns>Negated expression</returns>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.op_Addition(Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression)">
            <summary>
            Binary + operator
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.op_Addition(Analytics.Syntactic.BaseExpression,System.Double)">
            <summary>
            Binary + operator
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.op_Addition(System.Double,Analytics.Syntactic.BaseExpression)">
            <summary>
            Binary + operator
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.op_Addition(Analytics.Syntactic.BaseExpression,System.Int64)">
            <summary>
            Binary + operator
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.op_Addition(System.Int64,Analytics.Syntactic.BaseExpression)">
            <summary>
            Binary + operator
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.op_Subtraction(Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression)">
            <summary>
            Binary - operator
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.op_Subtraction(Analytics.Syntactic.BaseExpression,System.Double)">
            <summary>
            Binary - operator
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.op_Subtraction(System.Double,Analytics.Syntactic.BaseExpression)">
            <summary>
            Binary - operator
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.op_Subtraction(Analytics.Syntactic.BaseExpression,System.Int64)">
            <summary>
            Binary - operator
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.op_Subtraction(System.Int64,Analytics.Syntactic.BaseExpression)">
            <summary>
            Binary - operator
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.op_Multiply(Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression)">
            <summary>
            Binary * operator
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.op_Multiply(Analytics.Syntactic.BaseExpression,System.Double)">
            <summary>
            Binary * operator
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.op_Multiply(System.Double,Analytics.Syntactic.BaseExpression)">
            <summary>
            Binary * operator
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.op_Multiply(Analytics.Syntactic.BaseExpression,System.Int64)">
            <summary>
            Binary * operator
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.op_Multiply(System.Int64,Analytics.Syntactic.BaseExpression)">
            <summary>
            Binary * operator
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.op_Division(Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression)">
            <summary>
            Binary / operator
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.op_Division(Analytics.Syntactic.BaseExpression,System.Double)">
            <summary>
            Binary / operator
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.op_Division(System.Double,Analytics.Syntactic.BaseExpression)">
            <summary>
            Binary / operator
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.op_Division(Analytics.Syntactic.BaseExpression,System.Int64)">
            <summary>
            Binary / operator
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.op_Division(System.Int64,Analytics.Syntactic.BaseExpression)">
            <summary>
            Binary / operator
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.op_ExclusiveOr(Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression)">
            <summary>
            Binary ^ (power) operator.
            WARNING: C# ^ operator has lower precedence than algebraic ones
                     and it MUST BE ALWAYS ENCLOSED in parantheses for being
                     used correctly in mathematical meaning. Example (x^y)+z.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.op_ExclusiveOr(Analytics.Syntactic.BaseExpression,System.Double)">
            <summary>
            Binary ^ (power) operator.
            WARNING: C# ^ operator has lower precedence than algebraic ones
                     and it MUST BE ALWAYS ENCLOSED in parantheses for being
                     used correctly in mathematical meaning. Example (x^y)+z.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.op_ExclusiveOr(System.Double,Analytics.Syntactic.BaseExpression)">
            <summary>
            Binary ^ (power) operator.
            WARNING: C# ^ operator has lower precedence than algebraic ones
                     and it MUST BE ALWAYS ENCLOSED in parantheses for being
                     used correctly in mathematical meaning. Example (x^y)+z.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.op_ExclusiveOr(Analytics.Syntactic.BaseExpression,System.Int64)">
            <summary>
            Binary ^ (power) operator.
            WARNING: C# ^ operator has lower precedence than algebraic ones
                     and it MUST BE ALWAYS ENCLOSED in parantheses for being
                     used correctly in mathematical meaning. Example (x^y)+z.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.op_ExclusiveOr(System.Int64,Analytics.Syntactic.BaseExpression)">
            <summary>
            Binary ^ (power) operator.
            WARNING: C# ^ operator has lower precedence than algebraic ones
                     and it MUST BE ALWAYS ENCLOSED in parantheses for being
                     used correctly in mathematical meaning. Example (x^y)+z.
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.BaseExpression.Functions">
            <summary>
            Functional context
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.SimpleExpression">
            <summary>
            Base abstract class for all Simple Expressions.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.SimpleExpression.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.StructuredExpression">
            <summary>
            Base abstract class for all Structured Expressions.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.StructuredExpression.GetSelfPrecedence">
            <summary>
            Gets the Precedence of the expression type.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.StructuredExpression.GetPrecedence">
            <summary>
            Gets the Precedence of the structured expression
            taking into account degenerated case.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.StructuredExpression.Degenerate">
            <summary>
            Degenerates the expression.
            (by default does nothing, must be implemented in descendants)
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.StructuredExpression.ReplaceInside(System.String,Analytics.Syntactic.BaseExpression)">
            <summary>
            Replaces variable by given expression inside the contained expressions.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.StructuredExpression.GetExplicit(System.Boolean)">
            <summary>
            Gets copy of the expression, expanding containing implicit ones.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.StructuredExpression.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.StructuredExpression.Replace(System.String,Analytics.Syntactic.BaseExpression)">
            <summary>
            Replaces contained variable by given expression.
            </summary>
            <returns>Number of replaced occurencies</returns>
        </member>
        <member name="P:Analytics.Syntactic.StructuredExpression.IsDegenerated">
            <summary>
            Checks if the expression is degenerated
            (for example, after simplification x+0=0).
            Default is not, must be implemented in descendants.
            If true, the expression can be replaced with another one.
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.StructuredExpression.Degenerated">
            <summary>
            Returns the replacement expression for the degenerated case.
            WARNING: DOES NOT check if the expression is degenerated.
            Default - returns NULL, the expression is not degenerated.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.StructuredExpression.CopyExplicit(System.Boolean)">
            <summary>
            Creates copy of explicit expression (expands implicit operations)
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.StructuredExpression.ReplaceInList(System.Collections.Generic.List{Analytics.Syntactic.BaseExpression},System.String,Analytics.Syntactic.BaseExpression)">
            <summary>
            Replaces contained variable in all expressions of the list by given expression.
            Variable expression in the list are replaced directly.
            </summary>
            <returns>Total number of replacements.</returns>
        </member>
        <member name="T:Analytics.Syntactic.SymbolPair">
            <summary>
            Opening-Closing symbol pair
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.SymbolPair.#ctor(System.Char,System.Char)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.SymbolPair.Opening">
            <summary>
            Opening symbol
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.SymbolPair.Closing">
            <summary>
            Closing symbol
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.SymbolPair.Counter(System.Char)">
            <summary>
            Opening-closing counter
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.SymbolPair.op_Equality(Analytics.Syntactic.SymbolPair,Analytics.Syntactic.SymbolPair)">
            <summary>
            ==
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.SymbolPair.op_Inequality(Analytics.Syntactic.SymbolPair,Analytics.Syntactic.SymbolPair)">
            <summary>
            !=
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.SymbolPair.ToString">
            <summary>
            To string
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.SymbolPair.Equals(System.Object)">
            <summary>
            ==
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.SymbolPair.GetHashCode">
            <summary>
            Hash code
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.PairIndexes">
            <summary>
            Pair Indexes
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.PairIndexes.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.PairIndexes.Index1">
            <summary>
            The First Index
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.PairIndexes.Index2">
            <summary>
            The Second Index
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.PairIndexes.Length">
            <summary>
            Total length (including indexes) - calculated
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.PairIndexes.LengthInside">
            <summary>
            Length of inside items (excluding indexes) - calculated
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.PairIndexes.ToString">
            <summary>
            ToString
            </summary>
            <returns></returns>
        </member>
        <member name="T:Analytics.Syntactic.Elements">
            <summary>
            Syntactic elements
            </summary>
        </member>
        <member name="F:Analytics.Syntactic.Elements.FunctionBrackets">
            <summary>
            Function Brackets Pair
            </summary>
        </member>
        <member name="F:Analytics.Syntactic.Elements.IndexBrackets">
            <summary>
            Index Brackets Pair
            </summary>
        </member>
        <member name="F:Analytics.Syntactic.Elements.ParameterBrackets">
            <summary>
            Parameter Brackets Pair
            </summary>
        </member>
        <member name="F:Analytics.Syntactic.Elements.VectorBrackets">
            <summary>
            Vector Brackets Pair
            </summary>
        </member>
        <member name="F:Analytics.Syntactic.Elements.Brackets">
            <summary>
            All Brackets
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Elements.#cctor">
            <summary>
            Initializes all static data elements
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.Parser">
            <summary>
            Syntactic Parser
            </summary>
        </member>
        <member name="F:Analytics.Syntactic.Parser.evaluators">
            <summary>
            Literal Evaluators
            </summary>
        </member>
        <member name="F:Analytics.Syntactic.Parser.OperatorRules">
            <summary>
            Rules for operator parsing
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Parser.#cctor">
            <summary>
            Initializes all static data for parsing
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsValidName(System.String)">
            <summary>
            Checks if string is a valid name
            (contains alpha-numerics, '_' and SUBSCRIPT and SUPERSCRIPT DIGITS only and the first character is a letter,
             imaginary unit symbol allowed for name).
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsExponentSign(System.String,System.Int32)">
            <summary>
            Checks if the sign is a part of exponential number representation
            1.23E-4  5.67E+8  9.01e-2  3.45e+6
            (1.E-1 not allowed)
            </summary>
            <returns>True, if is</returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsNotExponentSign(System.String,System.Int32)">
            <summary>
            Sign is NOT a part of exponent number.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsPrefixSign(System.String,System.Int32)">
            <summary>
            Checks if the sign is a prefix unary (not binary)
            (cases: 1. The sign is the first character of the string)
                    2. The sign is right after a bracket
                    3. The sign is right after power operator
                    4. TODO: Think about OTHER cases...
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsNotPrefixSign(System.String,System.Int32)">
            <summary>
            Checks if the sign is NOT a prefix unary
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsOpening(System.Char,System.Collections.Generic.List{Analytics.Syntactic.SymbolPair})">
            <summary>
            Finds opening symbol in a pair list
            </summary>
            <param name="c"></param>
            <param name="pairs"></param>
            <returns>Number of pair, or -1 if not found</returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsClosing(System.Char,System.Collections.Generic.List{Analytics.Syntactic.SymbolPair})">
            <summary>
            Finds closing symbol in a pair list
            </summary>
            <returns>Number of pair, or -1 if not found</returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.UpdateLevel(System.Char,System.Collections.Generic.List{Analytics.Syntactic.SymbolPair},Analytics.LevelData)">
            <summary>
            Updates level for a list of pairs checking pair 
            compatibility and errors
            (the total level is a sum of levels
            or negative, if one level is negative - error)
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Parser.GetSubstring(System.String,Analytics.Syntactic.PairIndexes)">
            <summary>
            Gets substring (INCLUDING boundary chars)
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Parser.GetSubstringInside(System.String,Analytics.Syntactic.PairIndexes)">
            <summary>
            Gets substring (EXCLUDING boundary chars)
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Parser.FindPairMultilevel(System.String,System.Int32,Analytics.Syntactic.SymbolPair,System.Collections.Generic.List{Analytics.Syntactic.SymbolPair})">
            <summary>
            Finds pair of the first level
            (NOTE: does not check the levels syntax -
                   pairs can be uncompatible - "[}" for an example)
            TODO: Fix it;
            </summary>
            <returns>True, if found, if false - indexes indicates an error
            (-1,-1) - no pair of the first level
            (-1, >0) - opening expected
            (>=0, -1) - closing expected</returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.SplitMultilevel(System.String,System.Collections.Generic.List{System.Char},System.Collections.Generic.List{Analytics.Syntactic.SymbolPair},System.Boolean,Analytics.Syntactic.CharacterRuleSet)">
            <summary>
            Splits string by many separators using open-close pairs
            (checks errors of open-close pairs).
            Zero items (two separators beside) not allowed.
            </summary>
            <param name="value"></param>
            <param name="separators"></param>
            <param name="levels"></param>
            <param name="checkpairs">If false, does not check the pair open close and if error - returns the last
            part of the values as an item</param>
            <param name="rules"></param>
            <returns>List of items, or null if there are open-close errors</returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.SplitMultilevel(System.String,System.Collections.Generic.List{System.Char},System.Collections.Generic.List{Analytics.Syntactic.SymbolPair},System.Boolean)">
            <summary>
            Splits string by many separators using open-close pairs
            (checks errors of open-close pairs).
            Zero items (two separators beside) not allowed.
            </summary>
            <param name="value"></param>
            <param name="separators"></param>
            <param name="levels"></param>
            <param name="checkpairs">If false, does not check the pair open close and if error - returns the last
            part of the values as an item</param>
            <returns>List of items, or null if there are open-close errors</returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.SplitMultilevel(System.String,System.Char,System.Collections.Generic.List{Analytics.Syntactic.SymbolPair},System.Boolean)">
            <summary>
            Splits string by separator using open-close pairs
            (checks errors of open-close pairs, does not includes empty items)
            </summary>
            <param name="value"></param>
            <param name="separator"></param>
            <param name="levels"></param>
            <param name="checkpairs">If false, does not check the pair open close and if error - returns the last
            part of the values as an item</param>
            <returns>List of items, or null if there are open-close errors</returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsSurrounded(System.String,Analytics.Syntactic.SymbolPair,System.Collections.Generic.List{Analytics.Syntactic.SymbolPair})">
            <summary>
            Checks if the string is surrounded by a pair of symbols.
            </summary>
            <returns>True, if is surrounded + inside string</returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.RemoveSurrounders(System.String,Analytics.Syntactic.SymbolPair,System.Collections.Generic.List{Analytics.Syntactic.SymbolPair})">
            <summary>
            Removes all enclosing pairs
            </summary>
            <param name="value"></param>
            <param name="pair"></param>
            <param name="levels"></param>
            <returns>String without enclosing pairs</returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsFunction(System.String)">
            <summary>
            Checks if a string value has 'function like' format.
            NOTE: Does not check that the name is valid and parameters contain no errors.
            General function format
            name{p1 p2 ... pk}(a1 a2 ... an) - arguments are obligatory, parameters are not obligatory.
            the count of parameters and arguments can be 0, name cannot be empty.
            Name of the function, cannot be empty
            Parameters, can be null
            Arguments, can be null
            </summary>
            <returns>True, if the string has right format</returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsArrayItem(System.String)">
            <summary>
            Checks if a string value has 'array like' format.
            General (multidimentional) array format
            name[index1][index2]...[indexN]
            indexes can be empty strings.
            NOTE: does not check that indexes have valid format
                  (open-close compatibility only checked, because it is needed for array format)
            </summary>
            <returns>True, if valid format</returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsReal(System.String,System.Globalization.CultureInfo)">
            <summary>
            Checks if the string represents a Real value.
            NOTE: Automatically detects Infinity, Pi, E (see Symbols class).
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsReal(System.String,System.Boolean)">
            <summary>
            Checks if the string represents a Real value (for CURRENT CULTURE)
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsReal(System.String)">
            <summary>
            Checks if the string represents a Real value (for CURRENT CULTURE)
            </summary>
            <param name="value"></param>
            <returns>True, if valid</returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsRealConstant(System.Double)">
            <summary>
            Checks if the real number is a standard constant (Pi, e, ...).
            WARNING: Detection algorithm is based on comparison with the Constants.RealConstantPrecision value. 
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Parser.EvaluateReal(System.String)">
            <summary>
            Evaluates real literal.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Parser.RealToString(System.Double)">
            <summary>
            Converts Real to string.
            NOTE: it is recommended use this function for special cases,
                  where Double->String conversion required (for unified formatting)
                  because the algorithm can be developed for future purposes.
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsComplex(System.String,System.Globalization.CultureInfo)">
            <summary>
            Checks if the string represents a Complex value.
            Complex value syntax examples: 1.2+2.3I 
                                           -2.3I
                                           4I
                                           I
                                           -1.2e-3+4.5e+2I
                                           1.2e+2I
            TODO: think about other formats.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsComplex(System.String,System.Boolean)">
            <summary>
            Checks if the string represents a Complex value (for CURRENT CULTURE).
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsComplex(System.String)">
            <summary>
            Checks if the string represents a Complex value (for CURRENT CULTURE).
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsComplexConstant(System.Numerics.Complex)">
            <summary>
            Checks if the complex number can be simplified (I, 0, ...).
            WARNING: Detection algorithm is based on comparison with the Constants.RealConstantPrecision value. 
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Parser.EvaluateComplex(System.String)">
            <summary>
            Evaluates complex literal.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Parser.ComplexToString(System.Numerics.Complex)">
            <summary>
            Converts complex to string.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsBoolean(System.String,System.Globalization.CultureInfo)">
            <summary>
            Checks if the string represents a Boolean value.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsBoolean(System.String,System.Boolean)">
            <summary>
            Checks if the string represents a Boolean value for the current culture.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsBoolean(System.String)">
            <summary>
            Checks if the string represents a Boolean value for the current culture.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Parser.EvaluateBoolean(System.String)">
            <summary>
            Evaluates boolean value.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Parser.BooleanToString(System.Boolean)">
            <summary>
            Converts boolean to string.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Parser.RegisterLiteralEvaluator(Analytics.LiteralIs,Analytics.LiteralEvaluate)">
            <summary>
            Registers Literal Evaluator.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsLiteral(System.String)">
            <summary>
            Checks if the string is a literal.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Parser.EvaluateLiteral(System.String)">
            <summary>
            Evaluates literal.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsBinaryExpression(System.String,System.Collections.Generic.List{System.Char})">
            <summary>
            Check, if the string is a binary operations expression
            (can be devided into a sequence of expressions by some operators)
            </summary>
            <returns>True, if is</returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsLogicalExpression(System.String)">
            <summary>
            Check, if the string is a 'logical' expression
            (can be devided into a sequence of expressions by And, Or operators)
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsRelationalExpression(System.String)">
            <summary>
            Check, if the string is a 'relational' expression
            (can be devided into a sequence of expressions by Greater, Less, Equal etc. operators)
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsSummExpression(System.String)">
            <summary>
            Check, if the string is a 'summ' expression
            (can be devided into a sequence of expressions by + and - operators)
            </summary>
            <returns>True, if the string is a summ expression</returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsProductExpression(System.String)">
            <summary>
            Check, if the string is a 'product' expression
            (can be devided into a sequence of expressions by * and / operators)
            </summary>
            <returns>True, if the string is a product expression</returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsPowerExpression(System.String)">
            <summary>
            Check, if the string is a 'power' expression
            (can be devided into a sequence of expressions by ^ operator)
            </summary>
            <returns>True, if the string is a power expression</returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsArrowExpression(System.String)">
            <summary>
            Check, if the string is an 'arrow' expression
            (can be devided into a sequence of expressions by Arrow operators)
            </summary>
            <returns>True, if the string is an Arrow expression</returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsPrefixExpression(System.String)">
            <summary>
            The string value is a PREFIX expression
            (the first character is a prefix operator)
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsPostfixExpression(System.String)">
            <summary>
            The string value is a POSTFIX expression
            (the last character is a postfix operator)
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsOutfixExpression(System.String)">
            <summary>
            The string is Outfix expression (like absolute |operand|)
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsVectorExpression(System.String)">
            <summary>
            Check, if the string is a vector expression
            [e1 e2 ... eN]
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsMatrixExpression(System.String)">
            <summary>
            Check, if the string is a matrix expression
            [[e11 e12 ... e1N] [e21 e22 ... e2N] ... [eM1 eM2 ... eMN]]
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Parser.GetDerivativeOrder(System.String,System.Boolean,System.String@)">
            <summary>
            Gets order of derivative for expression after
            derivative operator: 'Superscript Digit'Operand or Variable'Superscript Digit'.
            NOTE: orders up to 9 supported (only one superscript digit).
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsDerivativeExpression(System.String)">
            <summary>
            Checks if the string is a derivative expression
            d'Superscript Digit'(Operand)/dX1'Superscript Digit'dX2'Superscript Digit'...dXN'Superscript Digit'
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsIntegralExpression(System.String)">
            <summary>
            Checks if the string is an integral expression
            I'Operand'dX
            </summary>
        </member>
        <member name="T:Analytics.Functions.FunctionalData">
            <summary>
            Data for user defined function.
            </summary>
        </member>
        <member name="P:Analytics.Functions.FunctionalData.Name">
            <summary>
            Name.
            </summary>
        </member>
        <member name="P:Analytics.Functions.FunctionalData.Variables">
            <summary>
            Functional Variable names.
            </summary>
        </member>
        <member name="P:Analytics.Functions.FunctionalData.Formula">
            <summary>
            Functional formula.
            </summary>
        </member>
        <member name="T:Analytics.Functions.FunctionalContext">
            <summary>
            Context for user defined functions.
            </summary>
        </member>
        <member name="P:Analytics.Functions.FunctionalContext.Item(System.String)">
            <summary>
            Functional data by name.
            </summary>
        </member>
        <member name="M:Analytics.Functions.FunctionalContext.Add(Analytics.Functions.FunctionalData)">
            <summary>
            Adds new Functional data - returns true if added,
            false - if a function with the same name exists.
            </summary>
        </member>
        <member name="M:Analytics.Functions.FunctionalContext.Remove(System.String)">
            <summary>
            Removes Functional data by name - returns true if deleted,
            false - if not existing.
            </summary>
        </member>
        <member name="M:Analytics.Functions.FunctionalContext.Clear">
            <summary>
            Removes all Functional data.
            </summary>
        </member>
        <member name="M:Analytics.Functions.FunctionalContext.Print">
            <summary>
            Prints all Functional data - for tests.
            </summary>
        </member>
        <member name="T:Analytics.Functions.BaseIfFunction">
            <summary>
            Base Abstract class for If function if{condition}(TRUE_VALUE FALSE_VALUE).
            Has one parameter (condition) of boolean type and two arguments of the same type as result.
            Implements default name and calculation algorithm - calculates conditional value and returns 
            the first argument if it is true and the second one if not.
            Only result type must be provided for final implementstion.
            NOTE: the behavior is not sealed and can be overriden for special cases.
            </summary>
        </member>
        <member name="T:Analytics.Functions.GenericIfFunction`1">
            <summary>
            Base Generic class for If function.
            Implements the result type based on the generic parameter.
            </summary>
        </member>
        <member name="T:Analytics.Functions.BaseArrayIfFunction`1">
            <summary>
            Base Abstract class for If with Boolean Array condition.
            NOTE: the behavior is not sealed and can be overriden for special cases.
            </summary>
        </member>
        <member name="T:Analytics.Functions.ArrayIfFunction`1">
            <summary>
            Base Abstract class for If with Boolean Array condition and ET[] arguments.
            Behaviour: result is ET[], R[i]= A1[i] if B[i] and A2[i] if not.
            NOTE: the behavior is not sealed and can be overriden for special cases.
            </summary>
        </member>
        <member name="T:Analytics.Functions.ArrayIfFunctionScalar`1">
            <summary>
            Base Abstract class for If with Boolean Array condition and scalar ET arguments.
            Behaviour: result is ET[], R[i]= A1 if B[i] and A2 if not.
            NOTE: the behavior is not sealed and can be overriden for special cases.
            </summary>
        </member>
        <member name="T:Analytics.Functions.ArrayIfFunctionScalar1`1">
            <summary>
            Base Abstract class for If with Boolean Array condition and ET, ET[] arguments.
            Behaviour: result is ET[], R[i]= A1 if B[i] and A2[i] if not.
            NOTE: the behavior is not sealed and can be overriden for special cases.
            </summary>
        </member>
        <member name="T:Analytics.Functions.ArrayIfFunctionScalar2`1">
            <summary>
            Base Abstract class for If with Boolean Array condition and ET[], ET arguments.
            Behaviour: result is ET[], R[i]= A1[i] if B[i] and A2 if not.
            NOTE: the behavior is not sealed and can be overriden for special cases.
            </summary>
        </member>
        <member name="T:Analytics.Functions.BaseMatrixIfFunction`1">
            <summary>
            Base Abstract class for If with Boolean Matrix condition.
            NOTE: the behavior is not sealed and can be overriden for special cases.
            </summary>
        </member>
        <member name="T:Analytics.Functions.MatrixIfFunction`1">
            <summary>
            Base Abstract class for If with Bolean Matrix condition and ET[,] arguments.
            Behaviour: result is ET[,], R[i,j]= A1[i,j] if B[i,j] and A2[i,j] if not.
            NOTE: the behavior is not sealed and can be overriden for special cases.
            </summary>
        </member>
        <member name="T:Analytics.Functions.MatrixIfFunctionScalar`1">
            <summary>
            Base Abstract class for If with Boolean Matrix condition and scalar ET arguments.
            Behaviour: result is ET[,], R[i][j]= A1 if B[i][j] and A2 if not.
            NOTE: the behavior is not sealed and can be overriden for special cases.
            </summary>
        </member>
        <member name="T:Analytics.Functions.MatrixIfFunctionScalar1`1">
            <summary>
            Base Abstract class for If with Boolean Matrix condition and ET, ET[,] arguments.
            Behaviour: result is ET[,], R[i][j]= A1 if B[i][j] and A2[i][j] if not.
            NOTE: the behavior is not sealed and can be overriden for special cases.
            </summary>
        </member>
        <member name="T:Analytics.Functions.MatrixIfFunctionScalar2`1">
            <summary>
            Base Abstract class for If with Boolean Matrix condition and ET[,], ET arguments.
            Behaviour: result is ET[,], R[i][j]= A1[i][j] if B[i][j] and A2 if not.
            NOTE: the behavior is not sealed and can be overriden for special cases.
            </summary>
        </member>
        <member name="T:Analytics.Functions.BaseComplexElementaryFunction">
            <summary>
            Base abstract class for all ELEMENTARY functions of COMPLEX ARGUMENTS
            </summary>
        </member>
        <member name="T:Analytics.Functions.ComplexElementaryFunction">
            <summary>
            Base abstract class for all ELEMENTARY functions
            of ONE COMPLEX argument and ZERO parameters (sin, ln, exp and so on).
            </summary>
        </member>
        <member name="M:Analytics.Functions.ComplexElementaryFunction.Func(System.Numerics.Complex)">
            <summary>
            The calculation function of ONE COMPLEX arqument
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Functions.ComplexParametricElementaryFunction">
            <summary>
            Base abstract class for all ELEMENTARY functions
            of ONE COMPLEX argument and ONE COMPLEX parameter (logarithm of x to base y).
            </summary>
        </member>
        <member name="M:Analytics.Functions.ComplexParametricElementaryFunction.Func(System.Numerics.Complex,System.Numerics.Complex)">
            <summary>
            The calculation function of ONE COMPLEX parameter and ONE COMPLEX arqument
            </summary>
            <param name="parameter"></param>
            <param name="argument"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Functions.BaseComplexSpecialFunction">
            <summary>
            Base abstract class for all SPECIAL functions of COMPLEX ARGUMENTS
            </summary>
        </member>
        <member name="T:Analytics.Functions.ComplexSpecialFunction">
            <summary>
            Base abstract class for all SPECIAL functions
            of ONE COMPLEX argument and ZERO parameters (abs, sgn and so on).
            </summary>
        </member>
        <member name="M:Analytics.Functions.ComplexSpecialFunction.Func(System.Numerics.Complex)">
            <summary>
            The calculation function of ONE COMPLEX arqument
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Functions.ComplexRealFunction">
            <summary>
            Base Abstract class for functions of ONE Complex argument
            those return DOUBLE values.
            NOTE: This class is out of main function class hierarchy
                  and used to simplify programming.
            </summary>
        </member>
        <member name="M:Analytics.Functions.ComplexRealFunction.Func(System.Numerics.Complex)">
            <summary>
            Calculation function
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Functions.ComplexRealParametricFunction">
            <summary>
            Base Abstract class for functions of ONE Complex parameter  
            and ONE Real argument those return COMPLEX values.
            NOTE: This class is out of main function class hierarchy
                  and used to simplify programming.
            </summary>
        </member>
        <member name="M:Analytics.Functions.ComplexRealParametricFunction.Func(System.Numerics.Complex,System.Double)">
            <summary>
            Calculation function
            </summary>
            <param name="par"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Functions.RealComplexParametricFunction">
            <summary>
            Base Abstract class for functions of ONE Real parameter  
            and ONE Complex argument those return COMPLEX values.
            NOTE: This class is out of main function class hierarchy
                  and used to simplify programming.
            </summary>
        </member>
        <member name="M:Analytics.Functions.RealComplexParametricFunction.Func(System.Double,System.Numerics.Complex)">
            <summary>
            Calculation function
            </summary>
            <param name="par"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Functions.GenericSimpleFunction`2">
            <summary>
            Generic Abstract class for functions with ONE argument (and ZERO parameters).
            </summary>
        </member>
        <member name="M:Analytics.Functions.GenericSimpleFunction`2.Func(`0)">
            <summary>
            The calculation Function.
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Functions.GenericBinaryFunction`3">
            <summary>
            Generic Abstract class for functions with TWO arguments (and ZERO parameters).
            </summary>
        </member>
        <member name="M:Analytics.Functions.GenericBinaryFunction`3.Func(`0,`1)">
            <summary>
            The calculation Function.
            </summary>
            <param name="x1"></param>
            <param name="x2"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Functions.GenericParametricFunction`3">
            <summary>
            Generic Abstract class for functions with ONE parameter and ONE argument.
            </summary>
        </member>
        <member name="M:Analytics.Functions.GenericParametricFunction`3.Func(`0,`1)">
            <summary>
            The calculation Function.
            </summary>
            <param name="p"></param>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Functions.GenericBinaryParametricFunction`4">
            <summary>
            Generic Abstract class for functions with ONE parameter and TWO arguments.
            </summary>
        </member>
        <member name="M:Analytics.Functions.GenericBinaryParametricFunction`4.Func(`0,`1,`2)">
            <summary>
            The calculation Function.
            </summary>
            <param name="p"></param>
            <param name="x1"></param>
            <param name="x2"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Functions.GenericBiparametricFunction`4">
            <summary>
            Generic Abstract class for functions with TWO parameters and ONE argument.
            </summary>
        </member>
        <member name="M:Analytics.Functions.GenericBiparametricFunction`4.Func(`0,`1,`2)">
            <summary>
            The calculation Function.
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Functions.GenericBinaryBiparametricFunction`5">
            <summary>
            Generic Abstract class for functions with TWO parameters and TWO arguments.
            </summary>
        </member>
        <member name="M:Analytics.Functions.GenericBinaryBiparametricFunction`5.Func(`0,`1,`2,`3)">
            <summary>
            The calculation Function.
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="x1"></param>
            <param name="x2"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Functions.Function">
            <summary>
            Abstract base class for any function.
            A Function has Name, number of arguments, argument types,
            number of parameters, parameter types and the Result type.
            NOTE (about parameters): parameter is an additional value that determines a function.
            For an example, the logarithm of 'x' to the base 'a' is a function
            of argument 'x' and with one parameter 'a'. Generally a parameter can
            be considered as a variable (or can depend on variables) but THIS
            library distinguishes ARGUMENTS and PARAMETERS.
            http://en.wikipedia.org/wiki/List_of_mathematical_functions
            </summary>
        </member>
        <member name="F:Analytics.Functions.Function.parameterTypes">
            <summary>
            Parameter types
            </summary>
        </member>
        <member name="F:Analytics.Functions.Function.argumentTypes">
            <summary>
            Argument types
            </summary>
        </member>
        <member name="F:Analytics.Functions.Function.resultType">
            <summary>
            Function result type
            </summary>
        </member>
        <member name="F:Analytics.Functions.Function.parameterValues">
            <summary>
            Current Values of Function Parameters
            </summary>
        </member>
        <member name="M:Analytics.Functions.Function.GetName">
            <summary>
            The function name
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Functions.Function.GetArgumentCount">
            <summary>
            The function argument count
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Functions.Function.GetArgumentTypes">
            <summary>
            Get Argument types
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Functions.Function.GetParameterCount">
            <summary>
            The function parameter count
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Functions.Function.GetParameterTypes">
            <summary>
            Get Parameter types
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Functions.Function.GetResultType">
            <summary>
            Get Result Type
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Functions.Function.DoCalculate(System.Object[],System.Object[])">
            <summary>
            Result calculation
            </summary>
            <param name="parameters"></param>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Functions.Function.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Analytics.Functions.Function.Name">
            <summary>
            Function name
            </summary>
        </member>
        <member name="P:Analytics.Functions.Function.ParameterCount">
            <summary>
            Parameter count
            (if negative - any parameter count aceptable)
            </summary>
        </member>
        <member name="P:Analytics.Functions.Function.ParameterTypes">
            <summary>
            Parameter types
            </summary>
        </member>
        <member name="P:Analytics.Functions.Function.ArgumentCount">
            <summary>
            Argument count
            (if negative - any argument count aceptable)
            </summary>
        </member>
        <member name="P:Analytics.Functions.Function.ArgumentTypes">
            <summary>
            Argument types
            </summary>
        </member>
        <member name="P:Analytics.Functions.Function.ResultType">
            <summary>
            Function Result Type
            </summary>
        </member>
        <member name="M:Analytics.Functions.Function.Calculate(System.Object[],System.Object[])">
            <summary>
            Result calculation
            </summary>
            <param name="parameters">Parameter values</param>
            <param name="arguments">Argument values</param>
            <returns>Calculation Result</returns>
        </member>
        <member name="M:Analytics.Functions.Function.ToString">
            <summary>
            To string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Functions.Function.ToTemplate(System.String)">
            <summary>
            Function template
            </summary>
            <param name="replacer"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Functions.MonotypeFunction">
            <summary>
            Monotype function is a function that has all
            parameters and arguments of ONE type (not Mathematical concept,
            usefull only as programming class).
            The type is based on GetResultType.
            </summary>
        </member>
        <member name="T:Analytics.Functions.BaseElementaryFunction">
            <summary>
            Base abstract class for all ELEMENTARY functions
            </summary>
        </member>
        <member name="T:Analytics.Functions.BaseRealElementaryFunction">
            <summary>
            Base abstract class for all ELEMENTARY functions of DOUBLE ARGUMENTS
            </summary>
        </member>
        <member name="T:Analytics.Functions.RealElementaryFunction">
            <summary>
            Base abstract class for all ELEMENTARY functions
            of ONE DOUBLE argument and ZERO parameters (sin, ln, exp and so on).
            </summary>
        </member>
        <member name="M:Analytics.Functions.RealElementaryFunction.Func(System.Double)">
            <summary>
            The calculation function of ONE DOUBLE arqument
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Functions.RealParametricElementaryFunction">
            <summary>
            Base abstract class for all ELEMENTARY functions
            of ONE DOUBLE argument and ONE DOUBLE parameter (logarithm of x to base y).
            </summary>
        </member>
        <member name="M:Analytics.Functions.RealParametricElementaryFunction.Func(System.Double,System.Double)">
            <summary>
            The calculation function of ONE DOUBLE parameter and ONE DOUBLE arqument
            </summary>
            <param name="parameter"></param>
            <param name="argument"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Functions.BaseSpecialFunction">
            <summary>
            Base abstract class for all SPECIAL functions
            </summary>
        </member>
        <member name="T:Analytics.Functions.BaseRealSpecialFunction">
            <summary>
            Base abstract class for all SPECIAL functions of DOUBLE ARGUMENTS
            </summary>
        </member>
        <member name="T:Analytics.Functions.RealSpecialFunction">
            <summary>
            Base abstract class for all SPECIAL functions
            of ONE DOUBLE argument and ZERO parameters (abs, sgn and so on).
            </summary>
        </member>
        <member name="M:Analytics.Functions.RealSpecialFunction.Func(System.Double)">
            <summary>
            The calculation function of ONE DOUBLE arqument
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Functions.BaseGenericFunction`1">
            <summary>
            Base abstract class for all Generic Functions.
            Introduces result type (because all functions have it).
            The inherited Generic functions introduce the number and the types
            of parameters and arguments simplifying implementation of final
            function types to only providing the name and the calculation algorithm.
            </summary>
            <typeparam name="ResultType"></typeparam>
        </member>
        <member name="T:Analytics.Names">
            <summary>
            These constants introduced to standardize all elementary and base special
            functions' names used everywhere in the code (for an example 'ln' in power derivative).
            </summary>
        </member>
        <member name="T:Analytics.OperationSet">
            <summary>
            Operations class contains a set of (registered) operators and functions
            (that is operations applicable to data of some types) used to build formulae.
            </summary>
        </member>
        <member name="F:Analytics.OperationSet.operators">
            <summary>
            Operators
            </summary>
        </member>
        <member name="F:Analytics.OperationSet.functions">
            <summary>
            Functions
            </summary>
        </member>
        <member name="M:Analytics.OperationSet.RecreateData">
            <summary>
            Recteates data
            </summary>
        </member>
        <member name="M:Analytics.OperationSet.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Analytics.OperationSet.GetAllFunctions">
            <summary>
            Gets all registered functions
            </summary>
            <returns></returns>
        </member>
        <member name="P:Analytics.OperationSet.Operators">
            <summary>
            Operator set
            </summary>
        </member>
        <member name="P:Analytics.OperationSet.Functions">
            <summary>
            Function set
            </summary>
        </member>
        <member name="M:Analytics.OperationSet.UpdateDefault">
            <summary>
            Updates default data
            </summary>
        </member>
        <member name="M:Analytics.OperationSet.Print">
            <summary>
            Gets information string (for tests only)
            </summary>
            <returns></returns>
        </member>
        <member name="T:Analytics.AutoOperations">
            <summary>
            Automatic Operations class registers all operator and function
            types using reflection mechanisms.
            NOTE: registers only SEALED classes (it is a hook to not use Run-time operators)
            </summary>
        </member>
        <member name="M:Analytics.AutoOperations.UpdateRegisteredOperators">
            <summary>
            Finds all operator types and adds operators to the operator set.
            </summary>
        </member>
        <member name="M:Analytics.AutoOperations.UpdateRegisteredFunctions">
            <summary>
            Finds all function types and adds functions to the function set.
            </summary>
        </member>
        <member name="M:Analytics.AutoOperations.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Analytics.AutoOperations.UpdateDefault">
            <summary>
            Updates default data
            </summary>
        </member>
        <member name="T:Analytics.Variables.ArrayVariable">
            <summary>
            Base abstract class for all (one dimentional) array variables. 
            </summary>
        </member>
        <member name="M:Analytics.Variables.ArrayVariable.SetValue(System.Object)">
            <summary>
            Sets data value and checks its parameters
            </summary>
            <param name="aValue"></param>
        </member>
        <member name="M:Analytics.Variables.ArrayVariable.ValueToString">
            <summary>
            Value to string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.ArrayVariable.GetIndexCount">
            <summary>
            1 index
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.ArrayVariable.#ctor(System.String,System.Array)">
            <summary>
            Constructor
            </summary>
            <param name="aName">Variable name</param>
            <param name="aValue">Variable value</param>
        </member>
        <member name="M:Analytics.Variables.ArrayVariable.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="aName">Variable name</param>
        </member>
        <member name="P:Analytics.Variables.ArrayVariable.Item(System.Int32)">
            <summary>
            Array element by index
            </summary>
            <param name="index"></param>
            <returns>Matrix element or null if data==null</returns>
        </member>
        <member name="P:Analytics.Variables.ArrayVariable.Length">
            <summary>
            Array Length
            </summary>
        </member>
        <member name="T:Analytics.Variables.MatrixVariable">
            <summary>
            Base abstract class for all matrix variables.
            NOTE: Slicing is implemented.
            </summary>
        </member>
        <member name="M:Analytics.Variables.MatrixVariable.SetValue(System.Object)">
            <summary>
            Sets data value and checks its parameters
            </summary>
            <param name="aValue"></param>
        </member>
        <member name="M:Analytics.Variables.MatrixVariable.ValueToString">
            <summary>
            Value to string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.MatrixVariable.GetIndexCount">
            <summary>
            2 indexes
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.MatrixVariable.#ctor(System.String,System.Array)">
            <summary>
            Constructor
            </summary>
            <param name="aName">Variable name</param>
            <param name="aValue">Variable value</param>
        </member>
        <member name="M:Analytics.Variables.MatrixVariable.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="aName">Variable name</param>
        </member>
        <member name="P:Analytics.Variables.MatrixVariable.Item(System.Int32,System.Int32)">
            <summary>
            Matrix element by indexes
            </summary>
            <param name="row"></param>
            <param name="column"></param>
            <returns>Array element or null if data==null</returns>
        </member>
        <member name="P:Analytics.Variables.MatrixVariable.RowCount">
            <summary>
            Row count
            </summary>
        </member>
        <member name="P:Analytics.Variables.MatrixVariable.ColumnCount">
            <summary>
            Column count
            </summary>
        </member>
        <member name="M:Analytics.Variables.MatrixVariable.GetSlicingImplemented">
            <summary>
            Slicing is implemented for Matrix variables
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.MatrixVariable.GetItemType(System.Int32[])">
            <summary>
            Sliced item is array of BaseType
            </summary>
            <param name="indexes"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.MatrixVariable.GetItemValue(System.Int32[])">
            <summary>
            Implements Array Slicing
            </summary>
            <param name="indexes"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Variables.BlockVariable">
            <summary>
            Base abstract class for all block variables.
            NOTE: slicing is implemented.
            </summary>
        </member>
        <member name="M:Analytics.Variables.BlockVariable.SetValue(System.Object)">
            <summary>
            Sets data value and checks its parameters
            </summary>
            <param name="aValue"></param>
        </member>
        <member name="M:Analytics.Variables.BlockVariable.ValueToString">
            <summary>
            Value to string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.BlockVariable.GetIndexCount">
            <summary>
            3 indexes
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.BlockVariable.#ctor(System.String,System.Array)">
            <summary>
            Constructor
            </summary>
            <param name="aName">Variable name</param>
            <param name="aValue">Variable value</param>
        </member>
        <member name="M:Analytics.Variables.BlockVariable.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="aName">Variable name</param>
        </member>
        <member name="P:Analytics.Variables.BlockVariable.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            Block element by indexes
            </summary>
            <param name="row"></param>
            <param name="column"></param>
            <param name="depth"></param>
            <returns>Block element or null if data==null</returns>
        </member>
        <member name="P:Analytics.Variables.BlockVariable.RowCount">
            <summary>
            Row count
            </summary>
        </member>
        <member name="P:Analytics.Variables.BlockVariable.ColumnCount">
            <summary>
            Column count
            </summary>
        </member>
        <member name="P:Analytics.Variables.BlockVariable.DepthCount">
            <summary>
            Depth count
            </summary>
        </member>
        <member name="M:Analytics.Variables.BlockVariable.GetSlicingImplemented">
            <summary>
            Slicing is implemented for Matrix variables
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.BlockVariable.GetItemType(System.Int32[])">
            <summary>
            Sliced item can be matrix or one dimentional array of BaseType.
            </summary>
            <param name="indexes"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.BlockVariable.GetItemValue(System.Int32[])">
            <summary>
            Implements Array Slicing
            </summary>
            <param name="indexes"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Variables.VariableSet">
            <summary>
            The set of variables
            </summary>
        </member>
        <member name="F:Analytics.Variables.VariableSet.data">
            <summary>
            Variables
            </summary>
        </member>
        <member name="M:Analytics.Variables.VariableSet.RecreateData">
            <summary>
            Recreates variables 
            </summary>
        </member>
        <member name="M:Analytics.Variables.VariableSet.AddVariable(Analytics.Variables.Variable)">
            <summary>
            Safely adds variable to the list
            </summary>
            <param name="v"></param>
        </member>
        <member name="M:Analytics.Variables.VariableSet.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Analytics.Variables.VariableSet.VariableExists(System.String)">
            <summary>
            Finds the variable number by name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="P:Analytics.Variables.VariableSet.VariableCount">
            <summary>
            Variable count
            </summary>
        </member>
        <member name="M:Analytics.Variables.VariableSet.Add(Analytics.Variables.Variable)">
            <summary>
            Adds the variable (if no variable with the same name exists
            and if variable is not null)
            </summary>
            <param name="v"></param>
            <returns>True, if added</returns>
        </member>
        <member name="P:Analytics.Variables.VariableSet.Item(System.String)">
            <summary>
            Indexing by Variable Name
            </summary>
            <param name="index">Variable name</param>
            <returns>Variable or null if not found</returns>
        </member>
        <member name="P:Analytics.Variables.VariableSet.Item(System.Int32)">
            <summary>
            Indexing by Variable index
            </summary>
            <param name="index">Variable index</param>
            <returns>Variable or null if index is out of range</returns>
        </member>
        <member name="P:Analytics.Variables.VariableSet.Data">
            <summary>
            Variable List
            </summary>
        </member>
        <member name="M:Analytics.Variables.VariableSet.Delete(System.String)">
            <summary>
            Deletes variable by name
            </summary>
            <param name="name"></param>
            <returns>True if deleted</returns>
        </member>
        <member name="M:Analytics.Variables.VariableSet.Delete(System.Int32)">
            <summary>
            Deletes variable by index
            </summary>
            <param name="index"></param>
            <returns>True if deleted</returns>
        </member>
        <member name="M:Analytics.Variables.VariableSet.Print">
            <summary>
            Gets information string (for tests only)
            </summary>
            <returns></returns>
        </member>
        <member name="T:Analytics.Variables.BooleanVariable">
            <summary>
            The Standard Boolean variable
            (contains Boolean value).
            </summary>
        </member>
        <member name="M:Analytics.Variables.BooleanVariable.Default">
            <summary>
            Default value (False)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.BooleanVariable.#ctor(System.String,System.Boolean)">
            <summary>
            Constructor 
            </summary>
            <param name="aName">Variable name</param>
            <param name="aValue">Variable value</param>
        </member>
        <member name="M:Analytics.Variables.BooleanVariable.#ctor(System.String)">
            <summary>
            Constructor 
            </summary>
            <param name="aName">Variable name</param>
        </member>
        <member name="T:Analytics.Variables.ObjectVariable">
            <summary>
            The General Scalar variable class
            that can contain ONE object (of any type).
            The variable data type is determined by the type of the object.
            </summary>
        </member>
        <member name="F:Analytics.Variables.ObjectVariable.objectType">
            <summary>
            The value type
            </summary>
        </member>
        <member name="M:Analytics.Variables.ObjectVariable.GetValueType">
            <summary>
            Value Type
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.ObjectVariable.SetValue(System.Object)">
            <summary>
            Sets data and assigns value type
            </summary>
            <param name="aValue"></param>
        </member>
        <member name="M:Analytics.Variables.ObjectVariable.AssignValueType">
            <summary>
            Assigns Value Type using current information
            (if object is not null - gets the type of the object,
            if null leaves the type unchanged)
            </summary>
        </member>
        <member name="M:Analytics.Variables.ObjectVariable.Default">
            <summary>
            Default value (not implemented)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.ObjectVariable.#ctor(System.String,System.Object,System.Type)">
            <summary>
            Constructor
            (the only one aValue or aType can be null)
            </summary>
            <param name="aName">Variable name</param>
            <param name="aValue">Variable value</param>
            <param name="aType">Variable type</param>
        </member>
        <member name="T:Analytics.Variables.ObjectArrayVariable">
            <summary>
            The General Array variable class
            that can contain ONE DIMENTIONAL ARRAY (of any base type).
            The base data type is determined by the type of the array.
            </summary>
        </member>
        <member name="F:Analytics.Variables.ObjectArrayVariable.baseType">
            <summary>
            The Base type
            </summary>
        </member>
        <member name="M:Analytics.Variables.ObjectArrayVariable.GetBaseType">
            <summary>
            Array Base type
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.ObjectArrayVariable.GetValueType">
            <summary>
            Array value type
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.ObjectArrayVariable.SetValue(System.Object)">
            <summary>
            Sets data and assigns base type
            </summary>
            <param name="aValue"></param>
        </member>
        <member name="M:Analytics.Variables.ObjectArrayVariable.AssignBaseType">
            <summary>
            Assigns Base Type using current information
            (if array is not null - gets the type of the array elements,
            if null leaves the type unchanged)
            </summary>
        </member>
        <member name="M:Analytics.Variables.ObjectArrayVariable.Default">
            <summary>
            Default value (not implemented)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.ObjectArrayVariable.#ctor(System.String,System.Object[],System.Type)">
            <summary>
            Constructor
            (the only one aValue or aBaseType can be null)
            </summary>
            <param name="aName">Variable name</param>
            <param name="aValue">Variable value</param>
            <param name="aBaseType">Base Array type</param>
        </member>
        <member name="T:Analytics.Variables.ObjectMatrixVariable">
            <summary>
            The General Matrix variable class
            that can contain TWO DIMENTIONAL ARRAY - MATRIX (of any base type).
            The base data type is determined by the type of the matrix.
            </summary>
        </member>
        <member name="F:Analytics.Variables.ObjectMatrixVariable.baseType">
            <summary>
            The Base type
            </summary>
        </member>
        <member name="M:Analytics.Variables.ObjectMatrixVariable.GetBaseType">
            <summary>
            Matrix base type
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.ObjectMatrixVariable.GetValueType">
            <summary>
            Matrix value type
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.ObjectMatrixVariable.SetValue(System.Object)">
            <summary>
            Sets data and assigns base type
            </summary>
            <param name="aValue"></param>
        </member>
        <member name="M:Analytics.Variables.ObjectMatrixVariable.AssignBaseType">
            <summary>
            Assigns Base Type using current information
            (if array is not null - gets the type of the array elements,
            if null leaves the type unchanged)
            </summary>
        </member>
        <member name="M:Analytics.Variables.ObjectMatrixVariable.Default">
            <summary>
            Default value (not implemented)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.ObjectMatrixVariable.#ctor(System.String,System.Object[0:,0:],System.Type)">
            <summary>
            Constructor
            (the only one aValue or aBaseType can be null)
            </summary>
            <param name="aName">Variable name</param>
            <param name="aValue">Variable value</param>
            <param name="aBaseType">Base Matrix type</param>
        </member>
        <member name="T:Analytics.Variables.ObjectBlockVariable">
            <summary>
            The General Block variable class
            that can contain THREE DIMENTIONAL ARRAY - BLOCK (of any base type).
            The base data type is determined by the type of the block.
            </summary>
        </member>
        <member name="F:Analytics.Variables.ObjectBlockVariable.baseType">
            <summary>
            The Base type
            </summary>
        </member>
        <member name="M:Analytics.Variables.ObjectBlockVariable.GetBaseType">
            <summary>
            Block base type
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.ObjectBlockVariable.GetValueType">
            <summary>
            Block value type
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.ObjectBlockVariable.SetValue(System.Object)">
            <summary>
            Sets data and assigns base type
            </summary>
            <param name="aValue"></param>
        </member>
        <member name="M:Analytics.Variables.ObjectBlockVariable.AssignBaseType">
            <summary>
            Assigns Base Type using current information
            (if array is not null - gets the type of the array elements,
            if null leaves the type unchanged)
            </summary>
        </member>
        <member name="M:Analytics.Variables.ObjectBlockVariable.Default">
            <summary>
            Default value (not implemented)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.ObjectBlockVariable.#ctor(System.String,System.Object[0:,0:,0:],System.Type)">
            <summary>
            Constructor
            (the only one aValue or aBaseType can be null)
            </summary>
            <param name="aName">Variable name</param>
            <param name="aValue">Variable value</param>
            <param name="aBaseType">Base Block type</param>
        </member>
        <member name="T:Analytics.Variables.RealVariable">
            <summary>
            The Standard Real variable
            (contains Double value).
            </summary>
        </member>
        <member name="M:Analytics.Variables.RealVariable.Default">
            <summary>
            Default value (0.0)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.RealVariable.#ctor(System.String,System.Double)">
            <summary>
            Constructor 
            </summary>
            <param name="aName">Variable name</param>
            <param name="aValue">Variable value</param>
        </member>
        <member name="M:Analytics.Variables.RealVariable.#ctor(System.String)">
            <summary>
            Constructor 
            </summary>
            <param name="aName">Variable name</param>
        </member>
        <member name="T:Analytics.Variables.RealArrayVariable">
            <summary>
            The Standard Real Array variable
            (contains Double array).
            </summary>
        </member>
        <member name="M:Analytics.Variables.RealArrayVariable.Default">
            <summary>
            Default value 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.RealArrayVariable.#ctor(System.String,System.Double[])">
            <summary>
            Constructor 
            </summary>
            <param name="aName">Variable name</param>
            <param name="aValue">Variable value</param>
        </member>
        <member name="M:Analytics.Variables.RealArrayVariable.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="aName">Variable name</param>
        </member>
        <member name="T:Analytics.Variables.RealMatrixVariable">
            <summary>
            The Standard Real Matrix variable
            (contains Double matrix).
            </summary>
        </member>
        <member name="M:Analytics.Variables.RealMatrixVariable.Default">
            <summary>
            Default value 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.RealMatrixVariable.#ctor(System.String,System.Double[0:,0:])">
            <summary>
            Constructor 
            </summary>
            <param name="aName">Variable name</param>
            <param name="aValue">Variable value</param>
        </member>
        <member name="M:Analytics.Variables.RealMatrixVariable.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="aName">Variable name</param>
        </member>
        <member name="T:Analytics.Variables.RealBlockVariable">
            <summary>
            The Standard Real Block variable
            (contains Double block).
            </summary>
        </member>
        <member name="M:Analytics.Variables.RealBlockVariable.Default">
            <summary>
            Default value 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.RealBlockVariable.#ctor(System.String,System.Double[0:,0:,0:])">
            <summary>
            Constructor 
            </summary>
            <param name="aName">Variable name</param>
            <param name="aValue">Variable value</param>
        </member>
        <member name="M:Analytics.Variables.RealBlockVariable.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="aName">Variable name</param>
        </member>
        <member name="T:Analytics.Variables.Variable">
            <summary>
            Base abstract class for all Variable types.
            
            All variables are separated into two categories:
            1. Scalar Variables - contain one value of some predefined type.
            2. Indexed Variables - contain set of values of some base type
                                   and allows indexing (for any index count).
            
            There are predefined indexed variables up to 3d dimension:
            array, matrix and 'block' variables.
            A Scalar variable contains ONE value of ANY type,
            an Array variable contains a row of indexed values,
            a Matrix contains a table of indexed values and
            a Block contains a 3D table of indexed values.
            </summary>
        </member>
        <member name="F:Analytics.Variables.Variable.name">
            <summary>
            Name
            </summary>
        </member>
        <member name="M:Analytics.Variables.Variable.GetValueType">
            <summary>
            The Type of Value the variable contains
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.Variable.GetValue">
            <summary>
            The Value the variable contains
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.Variable.SetValue(System.Object)">
            <summary>
            Sets the Variable Value
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.Variable.Default">
            <summary>
            Default variable value
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.Variable.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="aName">Variable name</param>
        </member>
        <member name="P:Analytics.Variables.Variable.Name">
            <summary>
            Name
            </summary>
        </member>
        <member name="P:Analytics.Variables.Variable.ValueType">
            <summary>
            The Type of Value
            </summary>
        </member>
        <member name="P:Analytics.Variables.Variable.Value">
            <summary>
            The Value
            </summary>
        </member>
        <member name="M:Analytics.Variables.Variable.TypeToString">
            <summary>
            Value type to string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.Variable.ValueToString">
            <summary>
            Value to string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.Variable.ToString">
            <summary>
            To string
            </summary>
            <returns></returns>
        </member>
        <member name="T:Analytics.Variables.ScalarVariable">
            <summary>
            Base abstract class for all scalar variables.
            </summary>
        </member>
        <member name="F:Analytics.Variables.ScalarVariable.data">
            <summary>
            Data value
            </summary>
        </member>
        <member name="M:Analytics.Variables.ScalarVariable.GetValue">
            <summary>
            Gets the value
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.ScalarVariable.ValueToString">
            <summary>
            Value to string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.ScalarVariable.#ctor(System.String,System.Object)">
            <summary>
            Constructor
            </summary>
            <param name="aName">Variable name</param>
            <param name="aValue">Variable value</param>
        </member>
        <member name="M:Analytics.Variables.ScalarVariable.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="aName">Variable name</param>
        </member>
        <member name="T:Analytics.Variables.IndexedVariable">
            <summary>
            Base abstract class for all indexed variables.
            </summary>
        </member>
        <member name="M:Analytics.Variables.IndexedVariable.GetBaseType">
            <summary>
            The Type of elements
            </summary>
        </member>
        <member name="M:Analytics.Variables.IndexedVariable.GetIndexCount">
            <summary>
            Gets index count
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.IndexedVariable.GetSlicingImplemented">
            <summary>
            Gets index count
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.IndexedVariable.#ctor(System.String,System.Object)">
            <summary>
            Constructor
            </summary>
            <param name="aName">Variable name</param>
            <param name="aValue">Variable Value</param>
        </member>
        <member name="M:Analytics.Variables.IndexedVariable.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="aName">Variable name</param>
        </member>
        <member name="P:Analytics.Variables.IndexedVariable.BaseType">
            <summary>
            The Type of Elements
            </summary>
        </member>
        <member name="P:Analytics.Variables.IndexedVariable.IndexCount">
            <summary>
            Index count
            </summary>
        </member>
        <member name="P:Analytics.Variables.IndexedVariable.IsSlicingImplemented">
            <summary>
            Slicing is implemented in GetItemValue
            </summary>
        </member>
        <member name="M:Analytics.Variables.IndexedVariable.GetItemValue(System.Int32[])">
            <summary>
            Gets Item value by its index values
            (can implement array slicing)
            </summary>
            <param name="indexes"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.IndexedVariable.GetItemType(System.Int32[])">
            <summary>
            If Array Slicing is implemented
            must be overriden and must return type for sliced item.
            </summary>
            <param name="indexes"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Variables.BaseArrayVariable">
            <summary>
            Base abstract class for all indexed variables
            using arrays to store data.
            </summary>
        </member>
        <member name="F:Analytics.Variables.BaseArrayVariable.data">
            <summary>
            Data value
            </summary>
        </member>
        <member name="M:Analytics.Variables.BaseArrayVariable.GetValue">
            <summary>
            Gets the (Array) value
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.BaseArrayVariable.SetValue(System.Object)">
            <summary>
            Sets data value (and checks that its type is an array)
            </summary>
            <param name="aValue"></param>
        </member>
        <member name="M:Analytics.Variables.BaseArrayVariable.GetSlicingImplemented">
            <summary>
            Slicing is NOT implemented for an Array variable by default.
            To implement GetItemValue must be overriden for the variable type.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.BaseArrayVariable.#ctor(System.String,System.Array)">
            <summary>
            Constructor
            </summary>
            <param name="aName">Variable name</param>
            <param name="aValue">Variable Value</param>
        </member>
        <member name="M:Analytics.Variables.BaseArrayVariable.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="aName">Variable name</param>
        </member>
        <member name="P:Analytics.Variables.BaseArrayVariable.Data">
            <summary>
            Value data
            </summary>
        </member>
        <member name="M:Analytics.Variables.BaseArrayVariable.GetItemValue(System.Int32[])">
            <summary>
            Gets item value from array data.
            TODO: implement array slicing
            </summary>
            <param name="indexes"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.BaseArrayVariable.GetItemType(System.Int32[])">
            <summary>
            Array Slicing is not implemented for arrays by default
            and this function returns BaseType.
            </summary>
            <param name="indexes"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Operators.NotOperator">
            <summary>
            Base abstract class for Logical Not operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.AndOperator">
            <summary>
            Base abstract class for Logical And operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.OrOperator">
            <summary>
            Base abstract class for Logical Or operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.IdenticallyOperator">
            <summary>
            Base abstract class for Relational Identity operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.ApproximatelyOperator">
            <summary>
            Base abstract class for Relational Approximately operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.NotequalOperator">
            <summary>
            Base abstract class for Relational Notequal operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GreaterOperator">
            <summary>
            Base abstract class for Relational Greater operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.LessOperator">
            <summary>
            Base abstract class for Relational Less operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GreaterorequalOperator">
            <summary>
            Base abstract class for Relational Greater or Equal operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.LessorequalOperator">
            <summary>
            Base abstract class for Relational Less or Equal operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.AddOperator">
            <summary>
            Base abstract class for Add (+) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.SubtractOperator">
            <summary>
            Base abstract class for Subtract (-) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.MultiplyOperator">
            <summary>
            Base abstract class for Multiply (*) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.DivideOperator">
            <summary>
            Base abstract class for Divide (/) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.DotOperator">
            <summary>
            Base abstract class for Dot (dot) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.CrossOperator">
            <summary>
            Base abstract class for Cross operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.PowerOperator">
            <summary>
            Base abstract class for Power (^) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.MinusOperator">
            <summary>
            Base abstract class for Unary Minus (-) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.SquareRootOperator">
            <summary>
            Base abstract class for Square Root operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.TildeOperator">
            <summary>
            Base abstract class for Tilde (~) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.FactorialOperator">
            <summary>
            Base abstract class for Factorial (!) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.ApostropheOperator">
            <summary>
            Base abstract class for Apostrophe (') operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.AccentOperator">
            <summary>
            Base abstract class for Accent (`) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.QuestionOperator">
            <summary>
            Base abstract class for Question (?) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.NumberOperator">
            <summary>
            Base abstract class for Number (#) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.AbsoluteOperator">
            <summary>
            Base abstract class for Absolute (||) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.NormOperator">
            <summary>
            Base abstract class for Norm operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.DerivativeOperator">
            <summary>
            Base abstract class for Derivative operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.IntegralOperator">
            <summary>
            Base abstract class for Integral operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.DeltaOperator">
            <summary>
            Base abstract class for Delta operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.SumOperator">
            <summary>
            Base abstract class for Sum operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.ProductOperator">
            <summary>
            Base abstract class for Product operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.LeftarrowOperator">
            <summary>
            Base abstract class for Left Arrow operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.RightarrowOperator">
            <summary>
            Base abstract class for Right Arrow operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.UparrowOperator">
            <summary>
            Base abstract class for Up Arrow operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.DownarrowOperator">
            <summary>
            Base abstract class for Down Arrow operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.LeftrightarrowOperator">
            <summary>
            Base abstract class for Left-Right Arrow operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.UpdownarrowOperator">
            <summary>
            Base abstract class for Up-Down Arrow operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.BaseGenericNotOperator`2">
            <summary>
            Base Generic class for Logical Not operators.
            </summary>
            <typeparam name="OperandType"></typeparam>
            <typeparam name="ReturnType"></typeparam>
        </member>
        <member name="T:Analytics.Operators.GenericNotOperator`1">
            <summary>
            Base Generic class for Logical Not operators with boolean return type.
            </summary>
            <typeparam name="OperandType"></typeparam>
        </member>
        <member name="T:Analytics.Operators.BaseGenericAndOperator`3">
            <summary>
            Base Generic class for Logical And operators.
            </summary>
            <typeparam name="Operand1Type"></typeparam>
            <typeparam name="Operand2Type"></typeparam>
            <typeparam name="ReturnType"></typeparam>
        </member>
        <member name="T:Analytics.Operators.GenericAndOperator`2">
            <summary>
            Base Generic class for Logical And operators with boolean return type.
            </summary>
            <typeparam name="Operand1Type"></typeparam>
            <typeparam name="Operand2Type"></typeparam>
        </member>
        <member name="T:Analytics.Operators.BaseGenericOrOperator`3">
            <summary>
            Base Generic class for Logical Or operators.
            </summary>
            <typeparam name="Operand1Type"></typeparam>
            <typeparam name="Operand2Type"></typeparam>
            <typeparam name="ReturnType"></typeparam>
        </member>
        <member name="T:Analytics.Operators.GenericOrOperator`2">
            <summary>
            Base Generic class for Logical Or operators with boolean return type.
            </summary>
            <typeparam name="Operand1Type"></typeparam>
            <typeparam name="Operand2Type"></typeparam>
        </member>
        <member name="T:Analytics.Operators.BaseGenericIdenticallyOperator`3">
            <summary>
            Base Generic class for Relational Identity operators.
            </summary>
            <typeparam name="Operand1Type"></typeparam>
            <typeparam name="Operand2Type"></typeparam>
            <typeparam name="ReturnType"></typeparam>
        </member>
        <member name="T:Analytics.Operators.GenericIdenticallyOperator`2">
            <summary>
            Base Generic class for Relational Identity operators with boolean return type.
            </summary>
            <typeparam name="Operand1Type"></typeparam>
            <typeparam name="Operand2Type"></typeparam>
        </member>
        <member name="T:Analytics.Operators.BaseGenericApproximatelyOperator`3">
            <summary>
            Base Generic class for Relational Approximately operators.
            </summary>
            <typeparam name="Operand1Type"></typeparam>
            <typeparam name="Operand2Type"></typeparam>
            <typeparam name="ReturnType"></typeparam>
        </member>
        <member name="T:Analytics.Operators.GenericApproximatelyOperator`2">
            <summary>
            Base Generic class for Relational Approximately operators with boolean return type.
            </summary>
            <typeparam name="Operand1Type"></typeparam>
            <typeparam name="Operand2Type"></typeparam>
        </member>
        <member name="T:Analytics.Operators.BaseGenericNotequalOperator`3">
            <summary>
            Base Generic class for Relational Notequal operators.
            </summary>
            <typeparam name="Operand1Type"></typeparam>
            <typeparam name="Operand2Type"></typeparam>
            <typeparam name="ReturnType"></typeparam>
        </member>
        <member name="T:Analytics.Operators.GenericNotequalOperator`2">
            <summary>
            Base Generic class for Relational Notequal operators with boolean return type.
            </summary>
            <typeparam name="Operand1Type"></typeparam>
            <typeparam name="Operand2Type"></typeparam>
        </member>
        <member name="T:Analytics.Operators.BaseGenericGreaterOperator`3">
            <summary>
            Base Generic class for Relational Greater operators.
            </summary>
            <typeparam name="Operand1Type"></typeparam>
            <typeparam name="Operand2Type"></typeparam>
            <typeparam name="ReturnType"></typeparam>
        </member>
        <member name="T:Analytics.Operators.GenericGreaterOperator`2">
            <summary>
            Base Generic class for Relational Greater operators with boolean return type.
            </summary>
            <typeparam name="Operand1Type"></typeparam>
            <typeparam name="Operand2Type"></typeparam>
        </member>
        <member name="T:Analytics.Operators.BaseGenericLessOperator`3">
            <summary>
            Base Generic class for Relational Less operators.
            </summary>
            <typeparam name="Operand1Type"></typeparam>
            <typeparam name="Operand2Type"></typeparam>
            <typeparam name="ReturnType"></typeparam>
        </member>
        <member name="T:Analytics.Operators.GenericLessOperator`2">
            <summary>
            Base Generic class for Relational Less operators with boolean return type.
            </summary>
            <typeparam name="Operand1Type"></typeparam>
            <typeparam name="Operand2Type"></typeparam>
        </member>
        <member name="T:Analytics.Operators.BaseGenericGreaterorequalOperator`3">
            <summary>
            Base Generic class for Relational Greater or Equal operators.
            </summary>
            <typeparam name="Operand1Type"></typeparam>
            <typeparam name="Operand2Type"></typeparam>
            <typeparam name="ReturnType"></typeparam>
        </member>
        <member name="T:Analytics.Operators.GenericGreaterorequalOperator`2">
            <summary>
            Base Generic class for Relational Greater or Equal operators with boolean return type.
            </summary>
            <typeparam name="Operand1Type"></typeparam>
            <typeparam name="Operand2Type"></typeparam>
        </member>
        <member name="T:Analytics.Operators.BaseGenericLessorequalOperator`3">
            <summary>
            Base Generic class for Relational Less or Equal operators.
            </summary>
            <typeparam name="Operand1Type"></typeparam>
            <typeparam name="Operand2Type"></typeparam>
            <typeparam name="ReturnType"></typeparam>
        </member>
        <member name="T:Analytics.Operators.GenericLessorequalOperator`2">
            <summary>
            Base Generic class for Relational Less or Equal operators with boolean return type.
            </summary>
            <typeparam name="Operand1Type"></typeparam>
            <typeparam name="Operand2Type"></typeparam>
        </member>
        <member name="T:Analytics.Operators.GenericAddOperator`3">
            <summary>
            Base Generic class for Add (+) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericSubtractOperator`3">
            <summary>
            Base Generic class for Subtract (-) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericMultiplyOperator`3">
            <summary>
            Base Generic class for Multiply (*) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericDivideOperator`3">
            <summary>
            Base Generic class for Divide (/) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericDotOperator`3">
            <summary>
            Base Generic class for Dot (dot) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericCrossOperator`3">
            <summary>
            Base Generic class for Cross operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericPowerOperator`3">
            <summary>
            Base Generic class for Power (^) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericMinusOperator`2">
            <summary>
            Base Generic class for Unary Minus (-) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericSquareRootOperator`2">
            <summary>
            Base Generic class for Square Root operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericTildeOperator`2">
            <summary>
            Base Generic class for Tilde (~) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericFactorialOperator`2">
            <summary>
            Base Generic class for Factorial (!) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericApostropheOperator`2">
            <summary>
            Base Generic class for Apostrophe (') operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericAccentOperator`2">
            <summary>
            Base Generic class for Accent operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericQuestionOperator`2">
            <summary>
            Base Generic class for Question (?) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericNumberOperator`2">
            <summary>
            Base Generic class for Number (#) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericAbsoluteOperator`2">
            <summary>
            Base Generic class for Absolute (||) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericNormOperator`2">
            <summary>
            Base Generic class for Norm operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericDerivativeOperator`2">
            <summary>
            Base abstract generic class for Derivative operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericIntegralOperator`2">
            <summary>
            Base abstract generic class for Integral operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericDeltaOperator`2">
            <summary>
            Base abstract generic class for Delta operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericSumOperator`2">
            <summary>
            Base abstract generic class for Sum operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericProductOperator`2">
            <summary>
            Base abstract generic class for Product operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericLeftarrowOperator`3">
            <summary>
            Base abstract generic class for Left Arrow operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericRightarrowOperator`3">
            <summary>
            Base abstract generic class for Right Arrow operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericUparrowOperator`3">
            <summary>
            Base abstract generic class for Up Arrow operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericDownarrowOperator`3">
            <summary>
            Base abstract generic class for Down Arrow operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericLeftrightarrowOperator`3">
            <summary>
            Base abstract generic class for Left-Right Arrow operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericUpdownarrowOperator`3">
            <summary>
            Base abstract generic class for Up-Down Arrow operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.RuntimeUnaryOperator">
            <summary>
            Unary operator created at run-time.
            Based on metainformation of a static method
            and intended to represent an overloaded operator.
            NOTE: Not SEALED to be not registered automatically (it is a hook).
            </summary>
        </member>
        <member name="M:Analytics.Operators.RuntimeUnaryOperator.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Analytics.Operators.RuntimeUnaryOperator.#ctor(Analytics.OperatorType,System.Reflection.MethodInfo)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="T:Analytics.Operators.RuntimeBinaryOperator">
            <summary>
            Binary operator created at run-time.
            Based on metainformation of a static method
            and intended to represent an overloaded operator.
            NOTE: Not SEALED to be not registered automatically (it is a hook).
            </summary>
        </member>
        <member name="M:Analytics.Operators.RuntimeBinaryOperator.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Analytics.Operators.RuntimeBinaryOperator.#ctor(Analytics.OperatorType,System.Reflection.MethodInfo)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericRuntimeUnaryOperator`2">
            <summary>
            Generic Unary operator created at run-time.
            NOTE: Not SEALED to be not registered automatically (it is a hook).
            </summary>
        </member>
        <member name="M:Analytics.Operators.GenericRuntimeUnaryOperator`2.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Analytics.Operators.GenericRuntimeUnaryOperator`2.#ctor(Analytics.OperatorType,Analytics.GenericUnaryOperation{`0,`1})">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericRuntimeBinaryOperator`3">
            <summary>
            Generic Binary operator created at run-time.
            NOTE: Not SEALED to be not registered automatically (it is a hook).
            </summary>
        </member>
        <member name="M:Analytics.Operators.GenericRuntimeBinaryOperator`3.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Analytics.Operators.GenericRuntimeBinaryOperator`3.#ctor(Analytics.OperatorType,Analytics.GenericBinaryOperation{`0,`1,`2})">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="T:Analytics.Operators.BooleanNotOperator">
            <summary>
            Logical Not operator
            </summary>
        </member>
        <member name="T:Analytics.Operators.BooleanAndOperator">
            <summary>
            Logical And operator
            </summary>
        </member>
        <member name="T:Analytics.Operators.BooleanOrOperator">
            <summary>
            Logical Or operator
            </summary>
        </member>
        <member name="T:Analytics.Operators.RealQuestionOperator">
            <summary>
            Real to Boolean conversion
            (True if value is not 0.0)
            </summary>
        </member>
        <member name="T:Analytics.Operators.BoolNumberOperator">
            <summary>
            Boolean to Real conversion (False - 0, True - 1)
            </summary>
        </member>
        <member name="T:Analytics.Operators.Operator">
            <summary>
            Base abstract class for all operators
            </summary>
        </member>
        <member name="M:Analytics.Operators.Operator.GetOperatorType">
            <summary>
            Operator type
            (must be implemented in intermediate abstract class
            as final and cannot be overriden in inherited classes)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Operators.Operator.GetReturnType">
            <summary>
            Return type (must be implemented in final class)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Operators.Operator.DoOperation(System.Object[])">
            <summary>
            Does operation
            (must be implemented in intermediate class (Unary, Binary)
            and cannot be overriden in inherited classes)
            </summary>
            <param name="operands"></param>
            <returns></returns>
        </member>
        <member name="P:Analytics.Operators.Operator.Type">
            <summary>
            Type of operator 
            </summary>
        </member>
        <member name="P:Analytics.Operators.Operator.ReturnType">
            <summary>
            Type of result 
            </summary>
        </member>
        <member name="P:Analytics.Operators.Operator.Arity">
            <summary>
            Arity (depends on Operator Type)
            </summary>
        </member>
        <member name="P:Analytics.Operators.Operator.Position">
            <summary>
            Position (depends on Operator Type)
            </summary>
        </member>
        <member name="P:Analytics.Operators.Operator.Sign">
            <summary>
            Operator Sign (depends on Operator Type)
            </summary>
        </member>
        <member name="M:Analytics.Operators.Operator.Calculate(System.Object[])">
            <summary>
            Calculates operation result
            </summary>
            <param name="operands"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Operators.UnaryOperator">
            <summary>
            Base abstract class for ALL Unary operators
            </summary>
        </member>
        <member name="M:Analytics.Operators.UnaryOperator.GetOperandType">
            <summary>
            Operand type
            (must be implemented in final class)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Operators.UnaryOperator.Operation(System.Object)">
            <summary>
            Operation with one operand
            </summary>
            <param name="operand"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Operators.UnaryOperator.DoOperation(System.Object[])">
            <summary>
            Does operation with one operand
            </summary>
            <param name="operands"></param>
            <returns></returns>
        </member>
        <member name="P:Analytics.Operators.UnaryOperator.OperandType">
            <summary>
            Type of operand 
            </summary>
        </member>
        <member name="M:Analytics.Operators.UnaryOperator.ToString">
            <summary>
            To string
            </summary>
            <returns></returns>
        </member>
        <member name="T:Analytics.Operators.BinaryOperator">
            <summary>
            Base abstract class for ALL Binary operators
            </summary>
        </member>
        <member name="M:Analytics.Operators.BinaryOperator.GetOperand1Type">
            <summary>
            Operand 1 type
            (must be implemented in final class)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Operators.BinaryOperator.GetOperand2Type">
            <summary>
            Operand 2 type
            (must be implemented in final class)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Operators.BinaryOperator.Operation(System.Object,System.Object)">
            <summary>
            Operation with two operands
            </summary>
            <param name="operand1"></param>
            <param name="operand2"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Operators.BinaryOperator.DoOperation(System.Object[])">
            <summary>
            Does operation with two operands
            </summary>
            <param name="operands"></param>
            <returns></returns>
        </member>
        <member name="P:Analytics.Operators.BinaryOperator.Operand1Type">
            <summary>
            Type of 1st operand 
            </summary>
        </member>
        <member name="P:Analytics.Operators.BinaryOperator.Operand2Type">
            <summary>
            Type of 2nd operand 
            </summary>
        </member>
        <member name="M:Analytics.Operators.BinaryOperator.ToString">
            <summary>
            To string
            </summary>
            <returns></returns>
        </member>
        <member name="T:Analytics.Operators.UnaryBooleanOperator">
            <summary>
            Unary operator with Boolean return type.
            </summary>
        </member>
        <member name="T:Analytics.Operators.BinaryBooleanOperator">
            <summary>
            Binary operator with Boolean return type.
            </summary>
        </member>
        <member name="T:Analytics.Operators.UnarySpecialOperator">
            <summary>
            Unary Special operator.
            (just for class hierarchy)
            </summary>
        </member>
        <member name="T:Analytics.Operators.BinarySpecialOperator">
            <summary>
            Binary Special operator.
            (just for class hierarchy)
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericUnaryOperator`2">
            <summary>
            Abstract Generic Unary operator. 
            </summary>
        </member>
        <member name="M:Analytics.Operators.GenericUnaryOperator`2.TypedOperation(`0)">
            <summary>
            Typed Unary Operator Operation.
            </summary>
            <param name="operand"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Operators.GenericUnaryOperator`2.Operation(System.Object)">
            <summary>
            Overrides Unary Operator Operation replacing it
            by typed one with automatic operand cast.
            </summary>
            <param name="operand"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Operators.GenericBinaryOperator`3">
            <summary>
            Abstract Generic Binary operator.
            </summary>
        </member>
        <member name="M:Analytics.Operators.GenericBinaryOperator`3.TypedOperation(`0,`1)">
            <summary>
            Typed Binary Operator Operation.
            </summary>
            <param name="operand1"></param>
            <param name="operand2"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Operators.GenericBinaryOperator`3.Operation(System.Object,System.Object)">
            <summary>
            Overrides Binary Operator Operation replacing it
            by typed one with automatic operands cast.
            </summary>
            <param name="operand1"></param>
            <param name="operand2"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Operators.GenericUnaryBooleanOperator`1">
            <summary>
            Abstract Generic Unary operator with boolean return type. 
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericBinaryBooleanOperator`2">
            <summary>
            Abstract Generic Binary operator with boolean return type. 
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericUnarySpecialOperator`2">
            <summary>
            Abstract Generic Unary Special operator.
            (just for class hierarchy)
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericBinarySpecialOperator`3">
            <summary>
            Abstract Generic Binary Special operator.
            (just for class hierarchy)
            </summary>
        </member>
        <member name="T:Analytics.Derivatives.DerivativeContext">
            <summary>
            Base class for Analytical Derivative Calculation context data
            (registers function derivatives).
            </summary>
        </member>
        <member name="F:Analytics.Derivatives.DerivativeContext.functions">
            <summary>
            List of functional derivatives
            </summary>
        </member>
        <member name="P:Analytics.Derivatives.DerivativeContext.FunctionDerivatives">
            <summary>
            Lazy initialized set of Function Derivatives for protected use.
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.DerivativeContext.GetIndex(System.String,System.Int32,System.Int32)">
            <summary>
            Finds function index by parameters
            </summary>
            <param name="func"></param>
            <param name="pcount"></param>
            <param name="acount"></param>
            <returns>index or -1</returns>
        </member>
        <member name="M:Analytics.Derivatives.DerivativeContext.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="P:Analytics.Derivatives.DerivativeContext.Item(System.String,System.Int32,System.Int32)">
            <summary>
            Finds Function Derivative by its parameters.
            </summary>
            <param name="func"></param>
            <param name="pcount"></param>
            <param name="acount"></param>
            <returns>Function derivative or null if no match found</returns>
        </member>
        <member name="M:Analytics.Derivatives.DerivativeContext.Add(Analytics.Derivatives.FunctionalDerivative)">
            <summary>
            Adds function derivative (if there is no function with the same arguments).
            </summary>
            <param name="d"></param>
            <returns>True if added</returns>
        </member>
        <member name="M:Analytics.Derivatives.DerivativeContext.Set(Analytics.Derivatives.FunctionalDerivative)">
            <summary>
            Sets function, if there is function with the same arguments,
            or adds it, if not.
            </summary>
            <param name="d"></param>
        </member>
        <member name="M:Analytics.Derivatives.DerivativeContext.Remove(System.String,System.Int32,System.Int32)">
            <summary>
            Romoves function derivative by parameters
            </summary>
            <param name="func"></param>
            <param name="pcount"></param>
            <param name="acount"></param>
            <returns>True, if removed</returns>
        </member>
        <member name="M:Analytics.Derivatives.DerivativeContext.Remove(System.Int32)">
            <summary>
            Romoves function derivative by index
            </summary>
            <param name="index"></param>
            <returns>True, if removed</returns>
        </member>
        <member name="M:Analytics.Derivatives.DerivativeContext.Clear">
            <summary>
            Clears the entire context
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.DerivativeContext.UpdateDefault">
            <summary>
            Updates default context.
            </summary>
        </member>
        <member name="P:Analytics.Derivatives.DerivativeContext.FunctionCount">
            <summary>
            Function count
            </summary>
        </member>
        <member name="T:Analytics.Derivatives.AutoDerivativeContext">
            <summary>
            Automative derivative context.
            (automatically finds and registers all functional derivative classes).
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.AutoDerivativeContext.UpdateRegisteredFunctions">
            <summary>
            Automatically finds and registers functional derivatives
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.AutoDerivativeContext.UpdateDefault">
            <summary>
            Finds and registers all nonabstract sealed function derivatives.
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.AutoDerivativeContext.#ctor">
            <summary>
            Default constructor (automatically finds and registers context data)
            </summary>
        </member>
        <member name="T:Analytics.Derivatives.FuncDiff">
            <summary>
            Functional derivative delegate.
            </summary>
        </member>
        <member name="T:Analytics.Derivatives.FunctionalDerivative">
            <summary>
            Base abstract class to define derivative for a function.
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.FunctionalDerivative.GetFunctionName">
            <summary>
            Returns the name of the function.
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.FunctionalDerivative.GetParameterCount">
            <summary>
            Returns the function parameter count.
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.FunctionalDerivative.GetArgumentCount">
            <summary>
            Returns the function argument count.
            </summary>
        </member>
        <member name="P:Analytics.Derivatives.FunctionalDerivative.FunctionName">
            <summary>
            Function name
            </summary>
        </member>
        <member name="P:Analytics.Derivatives.FunctionalDerivative.ParameterCount">
            <summary>
            Parameter count
            </summary>
        </member>
        <member name="P:Analytics.Derivatives.FunctionalDerivative.ArgumentCount">
            <summary>
            Argument count
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.FunctionalDerivative.Derivative(Analytics.Derivatives.DerivativeContext,Analytics.Syntactic.FunctionExpression,System.String)">
            <summary>
            Derivative calculation for the function.
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.FunctionalDerivative.ChainRule(Analytics.Derivatives.DerivativeContext,Analytics.Syntactic.FunctionExpression,System.Int32,Analytics.Derivatives.FuncDiff,System.String)">
            <summary>
            Implements base chain rule for function derivation process.
            </summary>
            <param name="context">Derivative Context</param>
            <param name="function">Function Expression</param>
            <param name="argument">Argument number for derivation</param>
            <param name="diff">Differential delegate for the argument</param>
            <param name="vName">Variable name for derivation</param>
            <returns>Derivative expression</returns>
        </member>
        <member name="M:Analytics.Derivatives.FunctionalDerivative.CheckParametersDependency(Analytics.Syntactic.FunctionExpression,System.String)">
            <summary>
            Checks all parameters for no dependency on the variable.
            If depends - throws 
            </summary>
        </member>
        <member name="T:Analytics.Derivatives.CompositeFunctionalDerivative">
            <summary>
            Base abstract class to define derivative function with one argument.
            Overrides Derivative method, based on the 'chain rule' formula
            d(f(g(x)))/dx = df/dg * dg/dx
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.CompositeFunctionalDerivative.FunctionDerivative(Analytics.Syntactic.FunctionExpression)">
            <summary>
            Creates derivative expression specific for the function.
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.CompositeFunctionalDerivative.Derivative(Analytics.Derivatives.DerivativeContext,Analytics.Syntactic.FunctionExpression,System.String)">
            <summary>
            Overrides Derivative method, based on the formula
            d(f(g(x)))/dx = df/dg * dg/dx
            </summary>
        </member>
        <member name="T:Analytics.Derivatives.BicompositeFunctionalDerivative">
            <summary>
            Base abstract class to define derivative function with TWO arguments.
            Overrides Derivative method, based on the 'chain rule' formula
            d(f(g(x),h(x)))/dx = df/dg * dg/dx + df/dh * dh/dx
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.BicompositeFunctionalDerivative.Function1Derivative(Analytics.Syntactic.FunctionExpression)">
            <summary>
            Creates derivative expression specific for the function for 1st argument.
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.BicompositeFunctionalDerivative.Function2Derivative(Analytics.Syntactic.FunctionExpression)">
            <summary>
            Creates derivative expression specific for the function for 2nd argument.
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.BicompositeFunctionalDerivative.Derivative(Analytics.Derivatives.DerivativeContext,Analytics.Syntactic.FunctionExpression,System.String)">
            <summary>
            Overrides Derivative method, based on the formula
            d(f(g(x),h(x)))/dx = df/dg * dg/dx + df/dh * dh/dx
            </summary>
        </member>
        <member name="T:Analytics.Derivatives.CompositeParametricDerivative">
            <summary>
            Base abstract class to define derivative function with one argument and (any number of) parameters
            that do not depend on the derivation variable. So, the derivation process also based on the.
            'chain rule' formula d(f(g(x)))/dx = df/dg * dg/dx
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.CompositeParametricDerivative.CheckParameters(Analytics.Syntactic.FunctionExpression,System.String)">
            <summary>
            Checks all parameters for no dependency on the variable.
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.CompositeParametricDerivative.Derivative(Analytics.Derivatives.DerivativeContext,Analytics.Syntactic.FunctionExpression,System.String)">
            <summary>
            Overrides Derivative method, introducing parameters checking for no dependency on the variable.
            </summary>
        </member>
        <member name="T:Analytics.Derivatives.BicompositeParametricDerivative">
            <summary>
            Base abstract class to define derivative function with TWO arguments and (any number of) parameters
            that do not depend on the derivation variable. So, the derivation process also based on the.
            'chain rule' formula d(f(g(x),h(x)))/dx = df/dg * dg/dx + df/dh * dh/dx
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.BicompositeParametricDerivative.CheckParameters(Analytics.Syntactic.FunctionExpression,System.String)">
            <summary>
            Checks all parameters for no dependency on the variable.
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.BicompositeParametricDerivative.Derivative(Analytics.Derivatives.DerivativeContext,Analytics.Syntactic.FunctionExpression,System.String)">
            <summary>
            Overrides Derivative method, introducing parameters checking for no dependency on the variable.
            </summary>
        </member>
        <member name="T:Analytics.Derivatives.SimpleFunctionalDerivative">
            <summary>
            Base abstract class to define derivative for simple
            function with one argument (and no parameters).
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.SimpleFunctionalDerivative.BaseDerivative(Analytics.Syntactic.BaseExpression)">
            <summary>
            Creates base derivative expression for the function's argument (df/dg).
            For an example, for the sine function it is cosine function of the same argument.
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.SimpleFunctionalDerivative.FunctionDerivative(Analytics.Syntactic.FunctionExpression)">
            <summary>
            Overrides function derivative for simple case of 1 argument.
            </summary>
        </member>
        <member name="T:Analytics.Derivatives.BinaryFunctionalDerivative">
            <summary>
            Base abstract class to define derivative for a
            function with two arguments (and no parameters).
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.BinaryFunctionalDerivative.BaseDerivative1(Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression)">
            <summary>
            Creates base derivative expression for the function's 1st argument (df/dg).
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.BinaryFunctionalDerivative.BaseDerivative2(Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression)">
            <summary>
            Creates base derivative expression for the function's 2nd argument (df/dh).
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.BinaryFunctionalDerivative.Function1Derivative(Analytics.Syntactic.FunctionExpression)">
            <summary>
            Overrides function derivative by 1st argument for the case of 2 arguments.
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.BinaryFunctionalDerivative.Function2Derivative(Analytics.Syntactic.FunctionExpression)">
            <summary>
            Overrides function derivative by 2nd argument for the case of 2 arguments.
            </summary>
        </member>
        <member name="T:Analytics.Derivatives.ParametricFunctionalDerivative">
            <summary>
            Base abstract class to define derivative for parametric
            function - with one parameter and one argument
            (for such functions, as log and special functions).
            WARNING: The class's base does override Derivative method by checking all parameters for no dependency on 
                     the derivation variable. If the derivative can be defined for functional parameters - override entire Derivative.
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.ParametricFunctionalDerivative.BaseDerivative(Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression)">
            <summary>
            Overrides function derivative for the case of 1 parameter and 1 argument.
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.ParametricFunctionalDerivative.FunctionDerivative(Analytics.Syntactic.FunctionExpression)">
            <summary>
            Overrides function derivative for the case of 1 parameter and 1 argument.
            </summary>
        </member>
        <member name="T:Analytics.Derivatives.BiparametricFunctionalDerivative">
            <summary>
            Base abstract class to define derivative for bi-parametric
            function - with two parameters and one argument
            (mainly for special functions - Legendre polinomial for an example).
            WARNING: The class's base does override Derivative method by checking all parameters for no dependency on 
                     the derivation variable. If the derivative can be defined for functional parameters - override entire Derivative.
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.BiparametricFunctionalDerivative.BaseDerivative(Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression)">
            <summary>
            Overrides function derivative for the case of 2 parameters and 1 argument.
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.BiparametricFunctionalDerivative.FunctionDerivative(Analytics.Syntactic.FunctionExpression)">
            <summary>
            Overrides function derivative for the case of 2 parameters and 1 argument.
            </summary>
        </member>
        <member name="T:Analytics.Derivatives.BinaryParametricFunctionalDerivative">
            <summary>
            Base abstract class to define derivative for parametric
            function - with one parameter and TWO arguments
            WARNING: The class's base does override Derivative method by checking all parameters for no dependency on 
                     the derivation variable. If the derivative can be defined for functional parameters - override entire Derivative.
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.BinaryParametricFunctionalDerivative.BaseDerivative1(Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression)">
            <summary>
            Overrides function derivative for 1st ARGUMENT
            for the case of 1 parameter and 2 arguments.
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.BinaryParametricFunctionalDerivative.BaseDerivative2(Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression)">
            <summary>
            Overrides function derivative for 2nd ARGUMENT
            for the case of 1 parameter and 2 arguments.
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.BinaryParametricFunctionalDerivative.Function1Derivative(Analytics.Syntactic.FunctionExpression)">
            <summary>
            Overrides function derivative by 1st argument
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.BinaryParametricFunctionalDerivative.Function2Derivative(Analytics.Syntactic.FunctionExpression)">
            <summary>
            Overrides function derivative by 2nd argument
            </summary>
        </member>
        <member name="T:Analytics.Derivatives.BinaryBiparametricFunctionalDerivative">
            <summary>
            Base abstract class to define derivative for parametric
            function - with TWO parameters and TWO arguments
            WARNING: The class's base does override Derivative method by checking all parameters for no dependency on 
                     the derivation variable. If the derivative can be defined for functional parameters - override entire Derivative.
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.BinaryBiparametricFunctionalDerivative.BaseDerivative1(Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression)">
            <summary>
            Overrides function derivative for 1st ARGUMENT
            for the case of 2 parameters and 2 arguments.
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.BinaryBiparametricFunctionalDerivative.BaseDerivative2(Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression)">
            <summary>
            Overrides function derivative for 2nd ARGUMENT
            for the case of 2 parameter and 2 arguments.
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.BinaryBiparametricFunctionalDerivative.Function1Derivative(Analytics.Syntactic.FunctionExpression)">
            <summary>
            Overrides function derivative by 1st argument
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.BinaryBiparametricFunctionalDerivative.Function2Derivative(Analytics.Syntactic.FunctionExpression)">
            <summary>
            Overrides function derivative by 2nd argument
            </summary>
        </member>
        <member name="T:Analytics.Expression">
            <summary>
            String Expression structure.
            Contains one string field and connected with it expression object.
            Overloads operators to manipulate with strings as expressions (multiply, negate and so on).
            All algorithms decompose strings into Syntactic Expression objects, then make operations with them, 
            simplify the result and finally reconstruct the result back to string.
            NOTE: an expression cannot be changed during lifetime and is simplified on creation.
            NOTE: only Explicit conversion from/to string is provided, because implicit one
                  can cause problems (then it could be written Expression*string, Expression+string and so on,
                  and this could make IMPLICIT effects).
            WARNING: all manipulated strings MUST be syntactically correct,
                     no check done inside the structure, exceptions can be thrown.
            </summary>
        </member>
        <member name="M:Analytics.Expression.#ctor(System.String)">
            <summary>
            Creates Expression from string value.
            Used in implicit conversion.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Analytics.Expression.#ctor(Analytics.Syntactic.BaseExpression)">
            <summary>
            Creates Expression structure by BaseExpression object.
            Used in overloaded operators to return result values.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Analytics.Expression.op_Explicit(Analytics.Expression)~System.String">
            <summary>
            Explicit conversion to string.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Expression.op_Explicit(System.String)~Analytics.Expression">
            <summary>
            Explicit conversion from string
            (the only way Expression structures must be created).
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Expression.op_UnaryNegation(Analytics.Expression)">
            <summary>
            Unary minus operator.
            </summary>
            <param name="operand"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Expression.op_Addition(Analytics.Expression,Analytics.Expression)">
            <summary>
            Binary + operator.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Expression.op_Subtraction(Analytics.Expression,Analytics.Expression)">
            <summary>
            Binary - operator.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Expression.op_Multiply(Analytics.Expression,Analytics.Expression)">
            <summary>
            Binary * operator.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Expression.op_Division(Analytics.Expression,Analytics.Expression)">
            <summary>
            Binary / operator.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Expression.op_ExclusiveOr(Analytics.Expression,Analytics.Expression)">
            <summary>
            Binary ^ (power) operator.
            WARNING: C# ^ operator has lower precedence than algebraic ones
                     and it MUST BE ALWAYS ENCLOSED in parantheses for being
                     used correctly in mathematical meaning. Example (x^y)+z.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Expression.Sqr(Analytics.Expression)">
            <summary>
            Square
            </summary>
            <param name="argument"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Expression.Sqrt(Analytics.Expression)">
            <summary>
            Square Root
            </summary>
            <param name="argument"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Expression.IsZero">
            <summary>
            Is Zero
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Expression.IsUnit">
            <summary>
            Is Unit
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Expression.IsInfinity">
            <summary>
            Is Infinity
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Expression.IsNaN">
            <summary>
            Is NaN
            </summary>
            <returns></returns>
        </member>
        <member name="T:Analytics.LiteralEvaluator">
            <summary>
            Class to evaluate literal expressions.
            </summary>
        </member>
        <member name="M:Analytics.LiteralEvaluator.#ctor(Analytics.LiteralIs,Analytics.LiteralEvaluate)">
            <summary>
            Constructor
            </summary>
            <param name="li"></param>
            <param name="le"></param>
        </member>
        <member name="P:Analytics.LiteralEvaluator.Is">
            <summary>
            Is function
            </summary>
        </member>
        <member name="P:Analytics.LiteralEvaluator.Evaluate">
            <summary>
            Evaluate function
            </summary>
        </member>
        <member name="T:Analytics.Messages">
            <summary>
            Messages
            (fields are public and not readonly and so can be localized).
            </summary>
        </member>
        <member name="T:Analytics.OperatorSet">
            <summary>
            Set of operators
            </summary>
        </member>
        <member name="F:Analytics.OperatorSet.data">
            <summary>
            Operators
            Each array index corresponds to the Operator Type.
            Undefined operator list is always null.
            </summary>
        </member>
        <member name="M:Analytics.OperatorSet.RecreateData">
            <summary>
            Recreates data
            </summary>
        </member>
        <member name="P:Analytics.OperatorSet.Item(Analytics.OperatorType)">
            <summary>
            Indexing by Operator Type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.OperatorSet.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Analytics.OperatorSet.Add(Analytics.Operators.Operator)">
            <summary>
            Adds the operator to the list
            </summary>
            <param name="op"></param>
        </member>
        <member name="M:Analytics.OperatorSet.FindUnary(Analytics.OperatorType,System.Type)">
            <summary>
            Finds unary operator
            </summary>
            <param name="type"></param>
            <param name="operand"></param>
            <returns>Unary operator or null</returns>
        </member>
        <member name="M:Analytics.OperatorSet.FindBinary(Analytics.OperatorType,System.Type,System.Type)">
            <summary>
            Finds binary operator
            </summary>
            <param name="type"></param>
            <param name="operand1"></param>
            <param name="operand2"></param>
            <returns>Binary operator or null</returns>
        </member>
        <member name="M:Analytics.OperatorSet.Clear">
            <summary>
            Clears all data
            </summary>
        </member>
        <member name="M:Analytics.OperatorSet.Print">
            <summary>
            Gets information string (for tests only)
            </summary>
            <returns></returns>
        </member>
        <member name="T:Analytics.FunctionSet">
            <summary>
            Set of functions
            </summary>
        </member>
        <member name="F:Analytics.FunctionSet.data">
            <summary>
            Functions
            </summary>
        </member>
        <member name="M:Analytics.FunctionSet.RecreateData">
            <summary>
            Recreates data
            </summary>
        </member>
        <member name="M:Analytics.FunctionSet.FindExact(System.Collections.Generic.List{Analytics.Functions.Function},System.Type[],System.Type[])">
            <summary>
            Finds function by types (exact coincidence)
            </summary>
            <param name="values"></param>
            <param name="parameters"></param>
            <param name="arguments"></param>
            <returns>Function or null</returns>
        </member>
        <member name="M:Analytics.FunctionSet.FindCompatible(System.Collections.Generic.List{Analytics.Functions.Function},System.Type[],System.Type[])">
            <summary>
            Finds function by types (compatibility)
            </summary>
            <param name="values"></param>
            <param name="parameters"></param>
            <param name="arguments"></param>
            <returns>Function or null</returns>
        </member>
        <member name="P:Analytics.FunctionSet.Item(System.String)">
            <summary>
            Indexing by function name
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.FunctionSet.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Analytics.FunctionSet.Add(Analytics.Functions.Function)">
            <summary>
            Add a function to the dictionary
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:Analytics.FunctionSet.FindFunction(System.String,System.Type[],System.Type[])">
            <summary>
            Finds function by name and types
            </summary>
            <param name="name"></param>
            <param name="parameters"></param>
            <param name="arguments"></param>
            <returns>Function or null</returns>
        </member>
        <member name="M:Analytics.FunctionSet.Clear">
            <summary>
            Clears all data
            </summary>
        </member>
        <member name="M:Analytics.FunctionSet.GetAll">
            <summary>
            Gets all functions
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.FunctionSet.Print">
            <summary>
            Gets information string (for tests only)
            </summary>
            <returns></returns>
        </member>
        <member name="T:Analytics.ConstantTranslator">
            <summary>
            Special translator class to evaluate CONSTANT expressions only.
            No operation registered by this translator class, so, only 'explicitely' 
            overloaded operators can be used to evaluate constant expressions.
            </summary>
        </member>
        <member name="M:Analytics.ConstantTranslator.RecreateOperations">
            <summary>
            Just creates empty operation set.
            </summary>
        </member>
        <member name="M:Analytics.ConstantTranslator.RecreateVariables">
            <summary>
            Variable == null, do not use.
            </summary>
        </member>
        <member name="M:Analytics.ConstantTranslator.RecreateDerivatives">
            <summary>
            Derivatives == null, do not use.
            </summary>
        </member>
        <member name="P:Analytics.ConstantTranslator.ConstantEvaluator">
            <summary>
            Static instance for constant expression evaluation.
            </summary>
        </member>
        <member name="T:Analytics.AnalyticsException">
            <summary>
            Base abstract class for all Analytics exceptions
            (to recognize simply the library specific exceptions)
            </summary>
        </member>
        <member name="M:Analytics.AnalyticsException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Analytics.WrongArgumentException">
            <summary>
            Argument Exception - got object is not what is expected
            </summary>
        </member>
        <member name="M:Analytics.WrongArgumentException.#ctor(System.String,System.Object,System.Object)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Analytics.NULLArgumentException">
            <summary>
            NULL Argument Exception
            </summary>
        </member>
        <member name="T:Analytics.OperationNotApplicableException">
            <summary>
            Operation not applicable for some data
            </summary>
        </member>
        <member name="M:Analytics.OperationNotApplicableException.#ctor(System.Object,System.Object)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Analytics.IntegerValueException">
            <summary>
            Error of value - it must be integer
            </summary>
        </member>
        <member name="M:Analytics.IntegerValueException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Analytics.NonnegativeValueException">
            <summary>
            Error of value - it must be nonnegative
            </summary>
        </member>
        <member name="M:Analytics.NonnegativeValueException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Analytics.InvalidNameException">
            <summary>
            Invalid Name Exception
            </summary>
        </member>
        <member name="T:Analytics.VariableValueTypeException">
            <summary>
            Error of Variable value type.
            </summary>
        </member>
        <member name="M:Analytics.VariableValueTypeException.#ctor(System.Type,System.Object)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Analytics.IndexCountException">
            <summary>
            Error of index count
            </summary>
        </member>
        <member name="M:Analytics.IndexCountException.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Analytics.IndexTypeException">
            <summary>
            Error of index type
            </summary>
        </member>
        <member name="M:Analytics.IndexTypeException.#ctor(System.Type,System.Type)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Analytics.IndexValueException">
            <summary>
            Error of index value
            </summary>
        </member>
        <member name="M:Analytics.IndexValueException.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Analytics.ParameterCountException">
            <summary>
            Error of parameter count
            </summary>
        </member>
        <member name="M:Analytics.ParameterCountException.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="expected"></param>
            <param name="got"></param>
        </member>
        <member name="T:Analytics.ParameterTypeException">
            <summary>
            Error of Parameter type
            </summary>
        </member>
        <member name="M:Analytics.ParameterTypeException.#ctor(System.Type,System.Type)">
            <summary>
            Constructor
            </summary>
            <param name="expected"></param>
            <param name="got"></param>
        </member>
        <member name="T:Analytics.ArgumentCountException">
            <summary>
            Error of Argument count
            </summary>
        </member>
        <member name="M:Analytics.ArgumentCountException.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="expected"></param>
            <param name="got"></param>
        </member>
        <member name="T:Analytics.ArgumentTypeException">
            <summary>
            Error of Argument type
            </summary>
        </member>
        <member name="M:Analytics.ArgumentTypeException.#ctor(System.Type,System.Type)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Analytics.OperandCountException">
            <summary>
            Error of Operand Count
            </summary>
        </member>
        <member name="M:Analytics.OperandCountException.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Analytics.UnknownLiteralException">
            <summary>
            Error of Literal Value
            </summary>
        </member>
        <member name="M:Analytics.UnknownLiteralException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Analytics.UnknownExpressionException">
            <summary>
            Error of Literal Value
            </summary>
        </member>
        <member name="M:Analytics.UnknownExpressionException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Analytics.UnsupportedExpressionTypeException">
            <summary>
            Unsupported expression type
            </summary>
        </member>
        <member name="M:Analytics.UnsupportedExpressionTypeException.#ctor(System.Type)">
            <summary>
            Constructor
            </summary>
            <param name="t">Type of expression</param>
        </member>
        <member name="M:Analytics.UnsupportedExpressionTypeException.#ctor(System.Object)">
            <summary>
            Constructor
            </summary>
            <param name="t">Type of expression</param>
        </member>
        <member name="T:Analytics.VariableNotFoundException">
            <summary>
            Variable not found
            </summary>
        </member>
        <member name="M:Analytics.VariableNotFoundException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Analytics.UnknownOperatorException">
            <summary>
            Unknown operator
            </summary>
        </member>
        <member name="M:Analytics.UnknownOperatorException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Analytics.UnaryOperatorNotFoundException">
            <summary>
            Unary operator not found
            </summary>
        </member>
        <member name="M:Analytics.UnaryOperatorNotFoundException.#ctor(System.String,System.Type)">
            <summary>
            Constructor
            </summary>
            <param name="sign">Operator sign</param>
            <param name="opnd">Operand type</param>
        </member>
        <member name="T:Analytics.BinaryOperatorNotFoundException">
            <summary>
            Binary operator not found
            </summary>
        </member>
        <member name="M:Analytics.BinaryOperatorNotFoundException.#ctor(System.String,System.Type,System.Type)">
            <summary>
            Constructor
            </summary>
            <param name="sign">Operator sign</param>
            <param name="opnd1">1st Operand type</param>
            <param name="opnd2">2nd Operand type</param>
        </member>
        <member name="T:Analytics.FunctionNotFoundException">
            <summary>
            Function not found
            </summary>
        </member>
        <member name="M:Analytics.FunctionNotFoundException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="signature">Function signature</param>
        </member>
        <member name="T:Analytics.SlicingNotImplementedException">
            <summary>
            Slicing not implemented
            </summary>
        </member>
        <member name="M:Analytics.SlicingNotImplementedException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="name">Function signature</param>
        </member>
        <member name="T:Analytics.SyntaxException">
            <summary>
            Base class for Syntax Error exceptions
            </summary>
        </member>
        <member name="F:Analytics.SyntaxException.error">
            <summary>
            Syntax error cosed the exception
            </summary>
        </member>
        <member name="M:Analytics.SyntaxException.#ctor(Analytics.Syntactic.SyntaxError)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Analytics.SyntaxException.Error">
            <summary>
            The Syntax error caused the exception.
            </summary>
        </member>
        <member name="T:Analytics.DerivativeException">
            <summary>
            Base class for derivative exceptions
            </summary>
        </member>
        <member name="T:Analytics.OperatorDerivativeException">
            <summary>
            Derivative not defined for operator exception
            </summary>
        </member>
        <member name="T:Analytics.OperationsDerivativeException">
            <summary>
            Derivative not defined for operations sequence exception
            </summary>
        </member>
        <member name="T:Analytics.FunctionDerivativeException">
            <summary>
            Derivative not defined for function exception
            </summary>
        </member>
        <member name="M:Analytics.FunctionDerivativeException.Create(System.String,System.Int32,System.Int32)">
            <summary>
            Creates the exception by parameters
            </summary>
        </member>
        <member name="T:Analytics.FunctionDerivativeParameterException">
            <summary>
            Function parameters must not depend on variable for Derivative exception
            </summary>
        </member>
        <member name="T:Analytics.OperationForbiddenException">
            <summary>
            Operation Forbidden
            </summary>
        </member>
        <member name="T:Analytics.Syntax">
            <summary>
            Static class to check syntax rules.
            Only to chek rules those have no need to decompose string value into expression sequence.
            For an example - parantheses compatibility, bad symbol sequence (*/, -*) and so on.
            Other errors (such as unknown functions and variables, wrong function argument count and so on)
            can be detected by Expression Build and Translator Build functions.
            </summary>
        </member>
        <member name="F:Analytics.Syntax.rules">
            <summary>
            Registered rules.
            </summary>
        </member>
        <member name="M:Analytics.Syntax.PairsRule(System.String,System.Collections.Generic.List{Analytics.Syntactic.SymbolPair})">
            <summary>
            Checks pair compatibility rule.
            There can be three cases of incompatibility:
            1. There is a closer and no opener - sin(x)*y).
            2. Some pairs are confused - sin(A[i)].
            3. There is an opener but no closer sin(2*A[1].
            </summary>
            <returns> 0 for no errors
                     -1 for error 1
                     -2 for error 2
                     +n for error 3</returns>
        </member>
        <member name="M:Analytics.Syntax.ParanthesesRule(System.String)">
            <summary>
            Parantheses compatibility rule.
            </summary>
        </member>
        <member name="M:Analytics.Syntax.SymbolParityRule(System.String,System.Char,System.Collections.Generic.List{Analytics.Syntactic.SymbolPair})">
            <summary>
            Checks parity rule for one char.
            The char is opening and closing symbol.
            If char is opened, all pairs must be closed, before the char is closed.
            (the function does not check pairs for rules)
            </summary>
            <returns>0, if there is no error</returns>
        </member>
        <member name="M:Analytics.Syntax.ParitiesRule(System.String)">
            <summary>
            Parities rule.
            </summary>
        </member>
        <member name="M:Analytics.Syntax.PairsNotAllowedRule(System.String,System.Collections.Generic.List{Analytics.Syntactic.SymbolPair})">
            <summary>
            Finds not allowed pairs of symbols.
            </summary>
            <returns> 0 for no errors
                     -1 if error pair found</returns>
        </member>
        <member name="M:Analytics.Syntax.InvalidConstructionRule(System.String)">
            <summary>
            Invalid construction rule.
            </summary>
        </member>
        <member name="M:Analytics.Syntax.BeginSymbolError(System.String,System.Collections.Generic.List{System.Char})">
            <summary>
            Begin symbol error
            </summary>
            <returns>TRUE, IF ERROR</returns>
        </member>
        <member name="M:Analytics.Syntax.EndSymbolError(System.String,System.Collections.Generic.List{System.Char})">
            <summary>
            End symbol error
            </summary>
            <returns>TRUE, IF ERROR</returns>
        </member>
        <member name="M:Analytics.Syntax.ErrorSymbolRule(System.String)">
            <summary>
            Error Symbol rule.
            </summary>
        </member>
        <member name="M:Analytics.Syntax.#cctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Analytics.Syntax.Check(System.String)">
            <summary>
            Checks string syntax correctness.
            </summary>
            <param name="value">A string to check</param>
            <returns>True, if correct, throws a syntax exception if not correct.</returns>
        </member>
        <member name="T:Analytics.Translator">
            <summary>
            Translator.
            Translator is a set of variables and operations
            so it can translate a formula (using syntax rules)
            and calculate it (using current variable values and registered operations).
            NOTE: It contains also a set of named constants realized as a set of static hidden variables. 
                  This set can be used to add nonstandard constants in translator
                  (standard constants Pi, e, ... are recognized now in Parser automatically).
                  The constants can be redefined by adding variables with the same names.
            </summary>
        </member>
        <member name="F:Analytics.Translator.constants">
            <summary>
            (Named) Constants (represented as a set of hidden variables)
            </summary>
        </member>
        <member name="M:Analytics.Translator.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="F:Analytics.Translator.variables">
            <summary>
            Variables
            </summary>
        </member>
        <member name="F:Analytics.Translator.operations">
            <summary>
            Operations
            </summary>
        </member>
        <member name="F:Analytics.Translator.derivatives">
            <summary>
            Derivatives
            </summary>
        </member>
        <member name="M:Analytics.Translator.RecreateVariables">
            <summary>
            Recreates variables 
            </summary>
        </member>
        <member name="M:Analytics.Translator.RecreateOperations">
            <summary>
            Recreates Syntax
            </summary>
        </member>
        <member name="M:Analytics.Translator.RecreateDerivatives">
            <summary>
            Recreates derivative context
            </summary>
        </member>
        <member name="M:Analytics.Translator.RecreateData">
            <summary>
            Recreates obligatory field data
            </summary>
        </member>
        <member name="M:Analytics.Translator.AddVariable(Analytics.Variables.Variable)">
            <summary>
            Just adds a variable into the list.
            </summary>
            <param name="v"></param>
        </member>
        <member name="M:Analytics.Translator.EvaluateLiteral(System.String)">
            <summary>
            Evaluates literal to an object
            (uses Parser's method).
            </summary>
        </member>
        <member name="P:Analytics.Translator.Operations">
            <summary>
            Current operation set
            </summary>
        </member>
        <member name="P:Analytics.Translator.VariableCount">
            <summary>
            Variable count
            </summary>
        </member>
        <member name="P:Analytics.Translator.Variables">
            <summary>
            Variable Set
            </summary>
        </member>
        <member name="M:Analytics.Translator.VariableExists(System.String)">
            <summary>
            Check if a variable with the name exists
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Translator.Add(Analytics.Variables.Variable)">
            <summary>
            Adds the variable (if no variable with the same name exists)
            </summary>
            <param name="v"></param>
            <returns>True, if added</returns>
        </member>
        <member name="M:Analytics.Translator.Add(System.String,System.Double)">
            <summary>
            Adds standard Real variable
            </summary>
            <param name="name"></param>
            <param name="value"></param>
            <returns>True, if added</returns>
        </member>
        <member name="M:Analytics.Translator.Add(System.String,System.Double[])">
            <summary>
            Adds standard Real Array variable
            </summary>
            <param name="name"></param>
            <param name="value"></param>
            <returns>True, if added</returns>
        </member>
        <member name="M:Analytics.Translator.Add(System.String,System.Double[0:,0:])">
            <summary>
            Adds standard Real Matrix variable
            </summary>
            <param name="name"></param>
            <param name="value"></param>
            <returns>True, if added</returns>
        </member>
        <member name="M:Analytics.Translator.Add(System.String,System.Double[0:,0:,0:])">
            <summary>
            Adds standard Real Block variable
            </summary>
            <param name="name"></param>
            <param name="value"></param>
            <returns>True, if added</returns>
        </member>
        <member name="M:Analytics.Translator.Get(System.String)">
            <summary>
            Gets variable by name
            </summary>
            <param name="name"></param>
            <returns>Variable or null if not found</returns>
        </member>
        <member name="M:Analytics.Translator.Get(System.Int32)">
            <summary>
            Gets variable by index
            </summary>
            <param name="index">Variable or null if index is out of bounds</param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Translator.Delete(System.String)">
            <summary>
            Deletes variable by name
            </summary>
            <param name="name"></param>
            <returns>True if deleted</returns>
        </member>
        <member name="M:Analytics.Translator.Delete(System.Int32)">
            <summary>
            Deletes variable by index
            </summary>
            <param name="index"></param>
            <returns>True if deleted</returns>
        </member>
        <member name="M:Analytics.Translator.DeleteAll">
            <summary>
            Deletes all variables
            </summary>
        </member>
        <member name="M:Analytics.Translator.BuildExpressionFormula(Analytics.Syntactic.BaseExpression)">
            <summary>
            Builds the formula by an expression (recursively)
            </summary>
            <param name="exp">Expression (CAN be NULL)</param>
            <returns>Formula, null (or throws an exception)</returns>
        </member>
        <member name="M:Analytics.Translator.BuildExpressionList(System.Collections.Generic.List{Analytics.Syntactic.BaseExpression})">
            <summary>
            Builds formulae from the expression list.
            </summary>
            <param name="list">List of expressions (can be null or empty).</param>
            <returns>List of formulae.</returns>
        </member>
        <member name="M:Analytics.Translator.BuildFormula(System.String)">
            <summary>
            Builds the formula for a string value.
            NOTE: formula string must be syntactically correct
                  (function does not check the syntax).
            </summary>
            <param name="value">Formula string</param>
            <returns>Formula, null or throws an exception</returns>
        </member>
        <member name="M:Analytics.Translator.BuildFormulae(System.String[])">
            <summary>
            Builds the formulae for the string values.
            NOTE: all formula strings must be syntactically correct
                  (function does not check the syntax).
            </summary>
            <param name="values">Formula strings</param>
            <returns>Formula, null or throws an exception</returns>
        </member>
        <member name="M:Analytics.Translator.BuildFormulaList(System.Collections.Generic.List{System.String})">
            <summary>
            Builds the formulae for the string values.
            NOTE: all formula strings must be syntactically correct
                  (function does not check the syntax).
            </summary>
            <param name="values">Formula strings</param>
            <returns>Formula, null or throws an exception</returns>
        </member>
        <member name="M:Analytics.Translator.Calculate(System.String)">
            <summary>
            Calculates formula value for current variable values.
            NOTE: formula string must be syntactically correct
                  (function does not check the syntax).
            </summary>
            <param name="value">Formula string</param>
            <returns>Calculated object, or throws an exception</returns>
        </member>
        <member name="M:Analytics.Translator.Calculate(Analytics.Syntactic.BaseExpression)">
            <summary>
            Calculates expression value for current variable values.
            </summary>
            <param name="expr">Expression</param>
            <returns>Calculated object, or throws an exception</returns>
        </member>
        <member name="M:Analytics.Translator.CheckSyntax(System.String)">
            <summary>
            Checks string syntax correctness.
            </summary>
            <param name="value">A string to check</param>
            <returns>True, if correct, throws a syntax exception if not correct.</returns>
        </member>
        <member name="M:Analytics.Translator.Simplify(System.String)">
            <summary>
            Simplifies string expression.
            NOTE: formula string must be syntactically correct
                  (function does not check the syntax).
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Translator.Explicit(System.String)">
            <summary>
            Returns explicit expression, expanding all implicit symbolic operations (derivative, ...).
            </summary>
        </member>
        <member name="M:Analytics.Translator.Evaluate(System.Collections.Generic.List{Analytics.Variables.Variable},Analytics.Syntactic.BaseExpression)">
            <summary>
            Partially evaluates expression by substituting current variable values
            from provided variable list.
            WARNING: for BOOLEAN/REAL/COMPLEX SCALAR/ARRAY/MATRIX variables only.
            </summary>
            <returns>True, if any substitution made.</returns>
        </member>
        <member name="M:Analytics.Translator.Evaluate(System.Collections.Generic.List{Analytics.Variables.Variable},System.String)">
            <summary>
            Partially evaluates string formula by substituting current variable values
            from provided variable list.
            WARNING: for BOOLEAN/REAL/COMPLEX SCALAR/ARRAY/MATRIX variables only.
            </summary>
            <returns>Evaluated value (or initial value if no substitution made)</returns>
        </member>
        <member name="M:Analytics.Translator.VariableNames(Analytics.Syntactic.BaseExpression)">
            <summary>
            Finds all variable names in the expression.
            </summary>
        </member>
        <member name="M:Analytics.Translator.VariableNames(System.String)">
            <summary>
            Finds all variable names in the string expression.
            </summary>
        </member>
        <member name="P:Analytics.Translator.Derivatives">
            <summary>
            Derivative context
            </summary>
        </member>
        <member name="M:Analytics.Translator.CalculateDerivative(Analytics.Syntactic.BaseExpression,System.String)">
            <summary>
            Calculates expression derivative
            (and simplifies result expression).
            NOTE: it is recommended to simplify expression first
                  to improve derivation process and result representation.
            </summary>
        </member>
        <member name="M:Analytics.Translator.Derivative(System.String,System.String)">
            <summary>
            Calculates derivative of the formula.
            (and simplifies result).
            NOTE: it uses initial expression simplification
                  to improve derivation process and result representation.
            </summary>
            <param name="formula">Formula</param>
            <param name="vName">Variable name.</param>
            <returns>Simplified result formula.</returns>
        </member>
        <member name="M:Analytics.Translator.Derivative(System.String,System.String,System.Int32)">
            <summary>
            Derivative of specified order.
            </summary>
        </member>
        <member name="M:Analytics.Translator.Derivative(System.String,System.String[])">
            <summary>
            Mixed derivative.
            </summary>
        </member>
        <member name="P:Analytics.Translator.Functions">
            <summary>
            Functional context
            </summary>
        </member>
        <member name="M:Analytics.Translator.AddFunction(System.String,System.String,System.String[])">
            <summary>
            Adds new Implicit (user defined) function.
            Returns true, if succesfully added, raises an exception if some error occured.
            </summary>
        </member>
        <member name="M:Analytics.Translator.RemoveFunction(System.String)">
            <summary>
            Removes Implicit (user defined) function by its name.
            Returns true, if removed, false - if not found.
            </summary>
        </member>
        <member name="M:Analytics.Translator.ClearFunctions">
            <summary>
            Removes all Functional data.
            </summary>
        </member>
        <member name="M:Analytics.Translator.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Analytics.Translator.Print">
            <summary>
            Gets information string (for tests only)
            </summary>
            <returns></returns>
        </member>
        <member name="T:Analytics.Converter">
            <summary>
            Value to String converter.
            </summary>
        </member>
        <member name="T:Analytics.Utilities">
            <summary>
            Utility class
            </summary>
        </member>
        <member name="M:Analytics.Utilities.GetOperatorSign(Analytics.OperatorType)">
            <summary>
            Operator Sign
            </summary>
        </member>
        <member name="M:Analytics.Utilities.GetOperatorType(System.String,Analytics.OperatorArity)">
            <summary>
            Gets operator type by its sign and arity.
            </summary>
        </member>
        <member name="M:Analytics.Utilities.GetOperatorPrecedence(Analytics.OperatorType)">
            <summary>
            Operator Precedence
            (operators with higher precedence applied before operators with lower precedence)
            </summary>
        </member>
        <member name="M:Analytics.Utilities.GetVariablePrecedence">
            <summary>
            Gets precedence of a variable or literal
            (use this function for compatibility with other operations precedence).
            </summary>
        </member>
        <member name="M:Analytics.Utilities.GetFunctionPrecedence">
            <summary>
            Gets precedence of a function
            (use this function for compatibility with other operations precedence).
            </summary>
        </member>
        <member name="M:Analytics.Utilities.GetArrayPrecedence">
            <summary>
            Gets precedence of an array or indexing expression
            (use this function for compatibility with other operations precedence).
            </summary>
        </member>
        <member name="M:Analytics.Utilities.GetOperatorArity(Analytics.OperatorType)">
            <summary>
            Operator arity
            </summary>
        </member>
        <member name="M:Analytics.Utilities.GetOperatorPosition(Analytics.OperatorType)">
            <summary>
            Operator position
            </summary>
        </member>
        <member name="M:Analytics.Utilities.GetBinaryOperationType(Analytics.OperatorType)">
            <summary>
            Returns binary operation type for the operator type
            or throws an EXCEPTION if the type is not defined.
            </summary>
        </member>
        <member name="M:Analytics.Utilities.GetBinaryOperationType(System.String)">
            <summary>
            Returns binary operation type for the operator type
            or throws an EXCEPTION if the type is not defined.
            </summary>
        </member>
        <member name="M:Analytics.Utilities.IsCommutative(Analytics.OperatorType)">
            <summary>
            Returns if a binary operation is commutative
            NOTE: throws an EXCEPTION if the type is not a binary operator.
            </summary>
        </member>
        <member name="M:Analytics.Utilities.IsCommutative(System.String)">
            <summary>
            Returns if a binary operation is commutative
            NOTE: throws an EXCEPTION if the type is not a binary operator.
            </summary>
        </member>
        <member name="M:Analytics.Utilities.OperatorCount">
            <summary>
            Defined Operator Count (excluding Undefined value)
            </summary>
        </member>
        <member name="M:Analytics.Utilities.IsDerivativeDefined(Analytics.OperatorType)">
            <summary>
            Checks, if derivative is defined for the operator type.
            </summary>
        </member>
        <member name="M:Analytics.Utilities.GetOverloadedOperatorName(Analytics.OperatorType)">
            <summary>
            Gets run-time method name for overloaded operator analogue.
            </summary>
            <param name="t"></param>
            <returns>Method name if analogue exists, null if not.</returns>
        </member>
        <member name="M:Analytics.Utilities.GetExplicitUnaryOperator(Analytics.OperatorType,System.Type)">
            <summary>
            Gets overloaded operator method from the type
            that corresponds to the unary operator type.
            </summary>
        </member>
        <member name="M:Analytics.Utilities.GetExplicitBinaryOperator(Analytics.OperatorType,System.Type,System.Type)">
            <summary>
            Gets overloaded operator method from the type
            that corresponds to the binary operator type.
            </summary>
        </member>
        <member name="M:Analytics.Utilities.SafeToString(System.Object)">
            <summary>
            Safe call ToString (for null object returns null symbol)
            Uses registered converters for result formatting.
            </summary>
        </member>
        <member name="M:Analytics.Utilities.GetTypeName(System.Type)">
            <summary>
            Safety gets type name
            </summary>
            <param name="t">Type (can be null)</param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Utilities.GetTypeNames(System.Type[])">
            <summary>
            Gets type names (safety)
            </summary>
        </member>
        <member name="M:Analytics.Utilities.SafeArrayLength(System.Array)">
            <summary>
            Safely gets the Length of the FIRST array dimension
            (for null value returns 0)
            </summary>
            <param name="x"></param>
            <returns>Length of the FIRST array dimension</returns>
        </member>
        <member name="M:Analytics.Utilities.SafeCount(System.Collections.IList)">
            <summary>
            Safely gets the element Count of the List
            (for null value returns 0)
            </summary>
            <param name="x"></param>
            <returns>Length of the FIRST array dimension</returns>
        </member>
        <member name="M:Analytics.Utilities.TypeEquals(System.Type,System.Type)">
            <summary>
            Compares Types
            </summary>
        </member>
        <member name="M:Analytics.Utilities.TypeCompatible(System.Type,System.Type)">
            <summary>
            Checks if the second type can be used instead of the first
            </summary>
        </member>
        <member name="M:Analytics.Utilities.TypesEqual(System.Type[],System.Type[])">
            <summary>
            Compares Type Arrays and returns two types that are not equal.
            </summary>
        </member>
        <member name="M:Analytics.Utilities.TypesCompatible(System.Type[],System.Type[])">
            <summary>
            Checks Type Arrays compatibility (the second can be used instead of the first) 
            and returns two types that are not compatible.
            </summary>
        </member>
        <member name="M:Analytics.Utilities.CheckNonnegativeArgument(System.Double,System.String)">
            <summary>
            Checks if the value is nonnegative.
            If not - throws exception.
            </summary>
        </member>
        <member name="M:Analytics.Utilities.IsInteger(System.Double,System.Int64@)">
            <summary>
            The value is integer (with precision).
            </summary>
        </member>
        <member name="M:Analytics.Utilities.IsInteger(System.Double,System.Int32@)">
            <summary>
            The value is integer (with precision).
            </summary>
        </member>
        <member name="M:Analytics.Utilities.IsFraction(System.Double,System.Int64@,System.Int64@)">
            <summary>
            The value can be presented as common fraction (up to the max value of numerator and denominator).
            </summary>
        </member>
        <member name="M:Analytics.Utilities.ToIntegers64(System.Double[])">
            <summary>
            Conversion to integers with values check.
            </summary>
        </member>
        <member name="M:Analytics.Utilities.ToIntegers(System.Double[])">
            <summary>
            Conversion to integers with values check.
            </summary>
        </member>
        <member name="M:Analytics.Utilities.CheckIntegerArgument(System.Double,System.String)">
            <summary>
            Checks if the value is "integer".
            If not - throws exception.
            </summary>
        </member>
        <member name="M:Analytics.Utilities.TryParseDouble(System.String,System.Globalization.CultureInfo)">
            <summary>
            Try parse double value
            </summary>
        </member>
        <member name="M:Analytics.Utilities.TryParseLong(System.String,System.Globalization.CultureInfo)">
            <summary>
            Try parse long value
            </summary>
        </member>
        <member name="M:Analytics.Utilities.TryParseBool(System.String)">
            <summary>
            Try parse boolean value
            </summary>
        </member>
        <member name="M:Analytics.Utilities.RegisterConverter(Analytics.Converter)">
            <summary>
            Register converter.
            </summary>
            <param name="converter"></param>
            <returns>True if not yet registered</returns>
        </member>
        <member name="T:Analytics.Symbols">
            <summary>
            Symbols used in expressions
            </summary>
        </member>
        <member name="F:Analytics.Symbols.NotOperator">
            <summary>
            Not
            </summary>
        </member>
        <member name="F:Analytics.Symbols.AndOperator">
            <summary>
            And
            </summary>
        </member>
        <member name="F:Analytics.Symbols.OrOperator">
            <summary>
            Or
            </summary>
        </member>
        <member name="F:Analytics.Symbols.IdenticallyOperator">
            <summary>
            Exact equal
            </summary>
        </member>
        <member name="F:Analytics.Symbols.ApproximatelyOperator">
            <summary>
            Approximately equal
            </summary>
        </member>
        <member name="F:Analytics.Symbols.NotequalOperator">
            <summary>
            Not Equal
            </summary>
        </member>
        <member name="F:Analytics.Symbols.GreaterOperator">
            <summary>
            Greater 
            </summary>
        </member>
        <member name="F:Analytics.Symbols.LessOperator">
            <summary>
            Less
            </summary>
        </member>
        <member name="F:Analytics.Symbols.GreaterorequalOperator">
            <summary>
            Greater or Equal
            </summary>
        </member>
        <member name="F:Analytics.Symbols.LessorequalOperator">
            <summary>
            Less or Equal
            </summary>
        </member>
        <member name="F:Analytics.Symbols.MinusOperator">
            <summary>
            Unary Minus
            </summary>
        </member>
        <member name="F:Analytics.Symbols.AddOperator">
            <summary>
            Binary Add
            </summary>
        </member>
        <member name="F:Analytics.Symbols.SubtractOperator">
            <summary>
            Binary subtract
            </summary>
        </member>
        <member name="F:Analytics.Symbols.MultiplyOperator">
            <summary>
            Multiply
            </summary>
        </member>
        <member name="F:Analytics.Symbols.DivideOperator">
            <summary>
            Divide
            </summary>
        </member>
        <member name="F:Analytics.Symbols.PowerOperator">
            <summary>
            Power
            </summary>
        </member>
        <member name="F:Analytics.Symbols.FactorialOperator">
            <summary>
            Factorial
            </summary>
        </member>
        <member name="F:Analytics.Symbols.ApostropheOperator">
            <summary>
            Apostrophe
            </summary>
        </member>
        <member name="F:Analytics.Symbols.AccentOperator">
            <summary>
            Accent (inverse) operator
            </summary>
        </member>
        <member name="F:Analytics.Symbols.DotOperator">
            <summary>
            Dot product
            </summary>
        </member>
        <member name="F:Analytics.Symbols.CrossOperator">
            <summary>
            Cross product
            </summary>
        </member>
        <member name="F:Analytics.Symbols.TildeOperator">
            <summary>
            Tilde (conjugate)
            </summary>
        </member>
        <member name="F:Analytics.Symbols.SquareRootOperator">
            <summary>
            Square Root
            </summary>
        </member>
        <member name="F:Analytics.Symbols.QuestionOperator">
            <summary>
            Question
            </summary>
        </member>
        <member name="F:Analytics.Symbols.NumberOperator">
            <summary>
            Number
            </summary>
        </member>
        <member name="F:Analytics.Symbols.DeltaOperator">
            <summary>
            Delta
            </summary>
        </member>
        <member name="F:Analytics.Symbols.SumOperator">
            <summary>
            Summ
            </summary>
        </member>
        <member name="F:Analytics.Symbols.ProductOperator">
            <summary>
            Product
            </summary>
        </member>
        <member name="F:Analytics.Symbols.LeftarrowOperator">
            <summary>
            Left arrow
            </summary>
        </member>
        <member name="F:Analytics.Symbols.RightarrowOperator">
            <summary>
            Right arrow
            </summary>
        </member>
        <member name="F:Analytics.Symbols.UparrowOperator">
            <summary>
            Up arrow
            </summary>
        </member>
        <member name="F:Analytics.Symbols.DownarrowOperator">
            <summary>
            Down arrow
            </summary>
        </member>
        <member name="F:Analytics.Symbols.LeftrightarrowOperator">
            <summary>
            Left-Right arrow
            </summary>
        </member>
        <member name="F:Analytics.Symbols.UpdownarrowOperator">
            <summary>
            Up-Down arrow
            </summary>
        </member>
        <member name="F:Analytics.Symbols.DerivativeOperator">
            <summary>
            Derivative
            </summary>
        </member>
        <member name="F:Analytics.Symbols.IntegralOperator">
            <summary>
            Integral
            </summary>
        </member>
        <member name="F:Analytics.Symbols.AbsoluteOperator">
            <summary>
            Absolute
            NOTE: realized only for not nested operations.
            </summary>
        </member>
        <member name="F:Analytics.Symbols.NormOperator">
            <summary>
            Norm
            NOTE: realized only for not nested operations.
            </summary>
        </member>
        <member name="F:Analytics.Symbols.AssignementOperator">
            <summary>
            Assignement
            TODO: not realized
            </summary>
        </member>
        <member name="F:Analytics.Symbols.ArgumentSeparator">
            <summary>
            Argument separator
            </summary>
        </member>
        <member name="F:Analytics.Symbols.VectorItemSeparator">
            <summary>
            Vector item separator
            </summary>
        </member>
        <member name="F:Analytics.Symbols.DerivativeSeparator">
            <summary>
            Vector item separator
            </summary>
        </member>
        <member name="F:Analytics.Symbols.ImaginarySymbol">
            <summary>
            Imaginary symbol
            </summary>
        </member>
        <member name="F:Analytics.Symbols.UnitSymbol">
            <summary>
            Unit symbol
            </summary>
        </member>
        <member name="F:Analytics.Symbols.ZeroSymbol">
            <summary>
            Zero symbol
            </summary>
        </member>
        <member name="F:Analytics.Symbols.ImaginaryString">
            <summary>
            Imaginary string
            </summary>
        </member>
        <member name="F:Analytics.Symbols.UnitString">
            <summary>
            Unit string
            </summary>
        </member>
        <member name="F:Analytics.Symbols.ZeroString">
            <summary>
            Zero string
            </summary>
        </member>
        <member name="F:Analytics.Symbols.InfinitySymbol">
            <summary>
            Infinity symbol
            </summary>
        </member>
        <member name="F:Analytics.Symbols.InfinityName">
            <summary>
            Infinity string (short)
            </summary>
        </member>
        <member name="F:Analytics.Symbols.InfinityFullName">
            <summary>
            Infinity string (full)
            </summary>
        </member>
        <member name="F:Analytics.Symbols.NaNName">
            <summary>
            NaN string
            </summary>
        </member>
        <member name="F:Analytics.Symbols.InfinityString">
            <summary>
            Infinity string (symbol)
            </summary>
        </member>
        <member name="F:Analytics.Symbols.PiSymbol">
            <summary>
            Pi symbol
            </summary>
        </member>
        <member name="F:Analytics.Symbols.PiName">
            <summary>
            Pi string
            </summary>
        </member>
        <member name="F:Analytics.Symbols.EulerSymbol">
            <summary>
            e symbol
            </summary>
        </member>
        <member name="F:Analytics.Symbols.PiString">
            <summary>
            Pi string (symbol)
            </summary>
        </member>
        <member name="F:Analytics.Symbols.EulerString">
            <summary>
            e string (symbol)
            </summary>
        </member>
        <member name="F:Analytics.Symbols.TrueName">
            <summary>
            True constant
            </summary>
        </member>
        <member name="F:Analytics.Symbols.FalseName">
            <summary>
            False constant
            </summary>
        </member>
        <member name="F:Analytics.Symbols.UniversalZeroSymbol">
            <summary>
            Universal zero symbol
            TODO: not realized (how to use?)
            </summary>
        </member>
        <member name="F:Analytics.Symbols.UniversalZeroString">
            <summary>
            Universal zero string
            </summary>
        </member>
        <member name="F:Analytics.Symbols.FunctionLeftBracket">
            <summary>
            Function left
            </summary>
        </member>
        <member name="F:Analytics.Symbols.FunctionRightBracket">
            <summary>
            Function right
            </summary>
        </member>
        <member name="F:Analytics.Symbols.IndexLeftBracket">
            <summary>
            Index left
            </summary>
        </member>
        <member name="F:Analytics.Symbols.IndexRightBracket">
            <summary>
            Index right
            </summary>
        </member>
        <member name="F:Analytics.Symbols.ParameterLeftBracket">
            <summary>
            Parameter left
            </summary>
        </member>
        <member name="F:Analytics.Symbols.ParameterRightBracket">
            <summary>
            Parameter right
            </summary>
        </member>
        <member name="F:Analytics.Symbols.LeftDoublequotation">
            <summary>
            Left double quotation
            </summary>
        </member>
        <member name="F:Analytics.Symbols.RightDoublequotation">
            <summary>
            Right double quotation
            </summary>
        </member>
        <member name="F:Analytics.Symbols.LeftQuotation">
            <summary>
            Left quotation
            </summary>
        </member>
        <member name="F:Analytics.Symbols.RightQuotation">
            <summary>
            Right quotation
            </summary>
        </member>
        <member name="F:Analytics.Symbols.LeftTrianglebracket">
            <summary>
            Left triangle
            </summary>
        </member>
        <member name="F:Analytics.Symbols.RightTrianglebracket">
            <summary>
            Right triangle
            </summary>
        </member>
        <member name="F:Analytics.Symbols.LeftDoubletrianglebracket">
            <summary>
            Left double triangle
            </summary>
        </member>
        <member name="F:Analytics.Symbols.RightDoubletrianglebracket">
            <summary>
            Right double triangle
            </summary>
        </member>
        <member name="F:Analytics.Symbols.FunctionSign">
            <summary>
            Function operator sign
            </summary>
        </member>
        <member name="F:Analytics.Symbols.NullValue">
            <summary>
            Null string
            </summary>
        </member>
        <member name="F:Analytics.Symbols.ReplacerSign">
            <summary>
            Replace symbol
            </summary>
        </member>
        <member name="F:Analytics.Symbols.NotDefinedSign">
            <summary>
            Not defined string
            </summary>
        </member>
        <member name="T:Analytics.NETRuntimeSymbols">
            <summary>
            NET Run-Time Symbols
            </summary>
        </member>
        <member name="F:Analytics.NETRuntimeSymbols.OperatorPrefix">
            <summary>
            NET run-time operator prefix
            </summary>
        </member>
        <member name="F:Analytics.NETRuntimeSymbols.AdditionName">
            <summary>
            + name
            </summary>
        </member>
        <member name="F:Analytics.NETRuntimeSymbols.SubtractionName">
            <summary>
            - (binary) name
            </summary>
        </member>
        <member name="F:Analytics.NETRuntimeSymbols.MultiplyName">
            <summary>
            * name
            </summary>
        </member>
        <member name="F:Analytics.NETRuntimeSymbols.DivisionName">
            <summary>
            / name
            </summary>
        </member>
        <member name="F:Analytics.NETRuntimeSymbols.NegationName">
            <summary>
            - (unary) name
            </summary>
        </member>
        <member name="F:Analytics.NETRuntimeSymbols.EqualityName">
            <summary>
            = name
            </summary>
        </member>
        <member name="F:Analytics.NETRuntimeSymbols.InequalityName">
            <summary>
            != name
            </summary>
        </member>
        <member name="F:Analytics.NETRuntimeSymbols.LessName">
            <summary>
            less name
            </summary>
        </member>
        <member name="F:Analytics.NETRuntimeSymbols.GreaterName">
            <summary>
            greater name
            </summary>
        </member>
        <member name="F:Analytics.NETRuntimeSymbols.LessorequalName">
            <summary>
            less or equal name
            </summary>
        </member>
        <member name="F:Analytics.NETRuntimeSymbols.GreaterorequalName">
            <summary>
            greater or equal
            </summary>
        </member>
        <member name="F:Analytics.NETRuntimeSymbols.NotName">
            <summary>
            not name
            </summary>
        </member>
        <member name="F:Analytics.NETRuntimeSymbols.AndName">
            <summary>
            and name
            </summary>
        </member>
        <member name="F:Analytics.NETRuntimeSymbols.OrName">
            <summary>
            or name
            </summary>
        </member>
        <member name="T:Analytics.OperatorType">
            <summary>
            All defined operators.
            - new operators cannot be defined;
            - the precedence of operators cannot be redefined;
            - the number of operator's operands cannot be redefined;
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Unknown">
            <summary>
            Unknown
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.And">
            <summary>
            logical and (binary)
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Or">
            <summary>
            logical or  (binary)
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Identically">
            <summary>
            equality (binary, relational)
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Approximately">
            <summary>
            approximate equality (binary, relational)
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Notequal">
            <summary>
            notequality (binary, relational)
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Greater">
            <summary>
            greater (binary, relational)
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Less">
            <summary>
            less (binary, relational)
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Greaterorequal">
            <summary>
            greater or equal (binary, relational)    
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Lessorequal">
            <summary>
            less or equal (binary, relational)
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Add">
            <summary>
            binary +
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Subtract">
            <summary>
            binary -
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Multiply">
            <summary>
            binary *
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Divide">
            <summary>
            binary /
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Dot">
            <summary>
            binary dot 
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Cross">
            <summary>
            binary cross
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Power">
            <summary>
            power ^ (binary)
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Leftarrow">
            <summary>
            Left arrow
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Rightarrow">
            <summary>
            Right arrow
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Uparrow">
            <summary>
            Up arrow
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Downarrow">
            <summary>
            Down arrow
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Leftrightarrow">
            <summary>
            Left-Right arrow
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Updownarrow">
            <summary>
            Up-Down arrow
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Not">
            <summary>
            logical not (unary prefix)
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Question">
            <summary>
            question (unary prefix)
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Number">
            <summary>
            Number (unary prefix)
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Minus">
            <summary>
            minus - (unary prefix)
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Tilde">
            <summary>
            tilde ~ (unary prefix)
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.SquareRoot">
            <summary>
            Square Root (unary prefix)
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Derivative">
            <summary>
            Derivative
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Integral">
            <summary>
            Integral
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Delta">
            <summary>
            Delta
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Sum">
            <summary>
            Summ
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Product">
            <summary>
            Product
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Factorial">
            <summary>
            factorial ! (unary postfix)
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Apostrophe">
            <summary>
            apostrophe ' (unary postfix)
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Accent">
            <summary>
            accent ` (inverse) (unary postfix)
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Absolute">
            <summary>
            absolute || (unary outfix)
            NOTE - this operator realized only for not nested operations.
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Norm">
            <summary>
            norm (unary outfix)
            NOTE - this operator realized only for not nested operations.
            </summary>
        </member>
        <member name="T:Analytics.OperatorArity">
            <summary>
            Operator arity
            </summary>
        </member>
        <member name="F:Analytics.OperatorArity.Nullary">
            <summary>
            Undefined arity
            </summary>
        </member>
        <member name="F:Analytics.OperatorArity.Unary">
            <summary>
            Unary
            </summary>
        </member>
        <member name="F:Analytics.OperatorArity.Binary">
            <summary>
            Binary
            </summary>
        </member>
        <member name="T:Analytics.OperatorPosition">
            <summary>
            Operator position
            </summary>
        </member>
        <member name="F:Analytics.OperatorPosition.Unknown">
            <summary>
            Unknown position
            </summary>
        </member>
        <member name="F:Analytics.OperatorPosition.Prefix">
            <summary>
            Prefix position
            </summary>
        </member>
        <member name="F:Analytics.OperatorPosition.Postfix">
            <summary>
            Postfix position
            </summary>
        </member>
        <member name="F:Analytics.OperatorPosition.Infix">
            <summary>
            Infix position
            </summary>
        </member>
        <member name="F:Analytics.OperatorPosition.Outfix">
            <summary>
            Outfix position
            </summary>
        </member>
        <member name="T:Analytics.OperatorAssociativity">
            <summary>
            Operator associativity.
            Determines the order in which the operators are applied.
            From left to right (+ operator) or from right to left (assignment operator).
            </summary>
        </member>
        <member name="F:Analytics.OperatorAssociativity.Unknown">
            <summary>
            Undefined
            </summary>
        </member>
        <member name="F:Analytics.OperatorAssociativity.Left">
            <summary>
            Left-associative
            </summary>
        </member>
        <member name="F:Analytics.OperatorAssociativity.Right">
            <summary>
            Right-associative
            </summary>
        </member>
        <member name="T:Analytics.BinaryOperationType">
            <summary>
            Binary Operation type defines the type
            of sequence of binary operations of the same precedence
            (example 'x-y+2' - sum, 'x/y*z' - product).
            </summary>
        </member>
        <member name="F:Analytics.BinaryOperationType.Unknown">
            <summary>
            Unknown
            </summary>
        </member>
        <member name="F:Analytics.BinaryOperationType.Logical">
            <summary>
            Logical operations
            </summary>
        </member>
        <member name="F:Analytics.BinaryOperationType.Relational">
            <summary>
            Relational operations
            </summary>
        </member>
        <member name="F:Analytics.BinaryOperationType.Sum">
            <summary>
            Summ operations
            </summary>
        </member>
        <member name="F:Analytics.BinaryOperationType.Product">
            <summary>
            Product operations
            </summary>
        </member>
        <member name="F:Analytics.BinaryOperationType.Power">
            <summary>
            Power operations
            </summary>
        </member>
        <member name="F:Analytics.BinaryOperationType.Arrow">
            <summary>
            Arrow operation
            </summary>
        </member>
    </members>
</doc>
